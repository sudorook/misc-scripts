#! /bin/bash
set -euo pipefail
source globals

! check_command ffmpeg iconv enconv && exit 3

#
# Globals
#

function convert_charset {
  local tmp
  local encoding

  if [[ "${1,,}" =~ belarusian ]]; then
    enconv -L belarusian "${1}" -x utf-8
  elif [[ "${1,,}" =~ bulgarian ]]; then
    enconv -L bulgarian "${1}" -x utf-8
  elif [[ "${1,,}" =~ czech ]]; then
    enconv -L czech "${1}" -x utf-8
  elif [[ "${1,,}" =~ estonian ]]; then
    enconv -L estonian "${1}" -x utf-8
  elif [[ "${1,,}" =~ croatian ]]; then
    enconv -L croatian "${1}" -x utf-8
  elif [[ "${1,,}" =~ hungarian ]]; then
    enconv -L hungarian "${1}" -x utf-8
  elif [[ "${1,,}" =~ lithuanian ]]; then
    enconv -L lithuanian "${1}" -x utf-8
  elif [[ "${1,,}" =~ latvian ]]; then
    enconv -L latvian "${1}" -x utf-8
  elif [[ "${1,,}" =~ polish ]]; then
    enconv -L polish "${1}" -x utf-8
  elif [[ "${1,,}" =~ russian ]]; then
    enconv -L russian "${1}" -x utf-8
  elif [[ "${1,,}" =~ slovak ]]; then
    enconv -L slovak "${1}" -x utf-8
  elif [[ "${1,,}" =~ slovene ]] || [[ "${1,,}" =~ slovenian ]]; then
    enconv -L slovene "${1}" -x utf-8
  elif [[ "${1,,}" =~ ukranian ]]; then
    enconv -L ukranian "${1}" -x utf-8
  elif [[ "${1,,}" =~ chinese ]]; then
    enconv -L chinese "${1}" -x utf-8
  else
    tmp="$(mktemp)"
    encoding="$(file -b --mime-encoding "$1")"
    case "${encoding}" in
      unknown-8bit)
        iconv -f cp1252 -t "utf-8" "${1}" > "${tmp}" && \
          mv "${tmp}" "${1}"
        ;;
      *)
        iconv -f "${encoding}" -t "utf-8" "${1}" > "${tmp}" && \
          mv "${tmp}" "${1}"
        ;;
    esac
  fi
}

function get_language {
  local res=
  for lang in "${!LANG[@]}"; do
    if [[ "${1,,}" =~ ${LANG[${lang}],,} ]]; then
      res="${lang}"
      break
    fi
  done

  # If language not found, try to parse three-character strings as a fallback.
  if [ -z "${res}" ]; then
    local end
    end="$(echo "${1}" | grep -o '[^\ ]*$')"
    for lang in "${!LANG[@]}"; do
      if [[ "${end,,}" =~ ${lang,,} ]]; then
        res="${lang}"
        break
      fi
    done
  fi
  echo "${res}"
}

function hardcode_cleanup {
  sed -i "s/\(\x92\|\x91\)/'/g" "${1}"
  sed -i "s/\(\x94\|\x93\)/\"/g" "${1}"
}

IN=${1}
NAME=${1%.*}
EXTENSION=${1##*.}
TMPVID="$(mktemp)"
SUBLIST=()

trap 'rm "${TMPVID}"; exit' INT TERM ERR

function detect_subs {
  local subext
  local encoding
  local sub
  local file

  for file in "${1}"*; do
    subext=${file##*.}
    case "${subext}" in
      ass|srt)
        encoding="$(file -b --mime-encoding "$file")"
        if ! [[ "${encoding}" = "utf-8" ]]; then
          show_info "Converting ${file} encoding from ${encoding} to utf-8."
          convert_charset "${file}"
        fi
        SUBLIST+=("${file}")
        ;;
      sub)
        if [ -f "${file%.*}.idx" ]; then
          show_info "INFO: Image subtitles detected. Output Matroska."
          EXTENSION=mkv
        fi
        SUBLIST+=("${file}")
        ;;
      avi|m4v|mp4|mkv|webm|idx)
        ;;
      *)
        show_warning "${file} not supported. Skipping..."
        ;;
    esac
  done
  if [ -d "Subs" ]; then
    for file in "Subs/"*; do
      subext=${file##*.}
      case "${subext}" in
        ass|srt)
          encoding="$(file -b --mime-encoding "$file")"
          if ! [[ "${encoding}" = "utf-8" ]]; then
            show_info "Converting ${file} encoding from ${encoding} to utf-8."
            convert_charset "${file}"
          fi
          SUBLIST+=("${file}")
          ;;
        sub)
          if [ -f "${file%.*}.idx" ]; then
            show_info "INFO: Image subtitles detected. Output Matroska."
            EXTENSION=mkv
          fi
          SUBLIST+=("${file}")
          ;;
        avi|m4v|mp4|mkv|webm|idx)
          ;;
        *)
          show_warning "${file} not supported. Skipping..."
          ;;
      esac
    done
  fi
  for sub in "${SUBLIST[@]}"; do
    echo "${sub}" >&2
  done
}

function make_cmd {
  local ext=${EXTENSION}
  local sub
  local subidx
  local subext
  local inputs
  local mapping
  local metadata
  local count
  local lang
  local eng_idx=0
  local cmd

  inputs="ffmpeg -i ${1@Q}"
  mapping="-map 0"
  metadata="-sub_charenc UTF-8"
  count=1
  if [[ "${#SUBLIST[@]}" = 1 ]]; then
    sub="${SUBLIST[0]}"
    subext="${sub##*.}"
    if [[ "${subext}" = "sub" ]]; then
      subidx="${sub%.*}.idx"
      inputs="${inputs} -i ${subidx@Q} -i ${sub@Q}"
    else
      inputs="${inputs} -i ${sub@Q}"
    fi
    mapping="${mapping} -map 1:s"
    metadata="${metadata} -metadata:s:s:0 language=eng"
    metadata="${metadata} -metadata:s:s:0 handler=\"English\""
  elif [[ "${#SUBLIST[@]}" -gt 1 ]]; then
    for sub in "${SUBLIST[@]}"; do
      subext="${sub##*.}"
      subidx="${sub%.*}.idx"
      if [[ "${subext}" = "sub" ]] && [ -f "${subidx}" ]; then
        inputs="${inputs} -i ${subidx@Q} -i ${sub@Q}"
        mapping="${mapping} -map ${count}:s -map $((count + 1)):s"
        if [[ "${sub,,}" =~ english ]] && [[ "${eng_idx}" == 0 ]]; then
          eng_idx="$((count - 1))"
        fi
        lang="$(get_language "${sub}")"
        if [ -n "${lang}" ]; then
          metadata="${metadata} -metadata:s:s:$((count - 1)) language=\"${lang}\""
          metadata="${metadata} -metadata:s:s:$((count - 1)) handler=\"${LANG[$lang]}\""
        fi
        count=$((count + 2))
      else
        inputs="${inputs} -i ${sub@Q}"
        mapping="${mapping} -map ${count}:s"
        lang="$(get_language "${sub}")"
        if [ -n "${lang}" ]; then
          if [[ "${lang}" = "eng" ]] && [[ "${eng_idx}" = 0 ]]; then
            eng_idx="$((count - 1))"
          fi
          metadata="${metadata} -metadata:s:s:$((count - 1)) language=\"${lang}\""
          metadata="${metadata} -metadata:s:s:$((count - 1)) handler=\"${LANG[$lang]}\""
        fi
        count=$((count + 1))
      fi
    done
  fi

  case ${ext} in
    avi)
      # AVI does not support embedding text-based subtitles, so convert to MP4
      # and embed as mov_text.
      EXTENSION="mkv"
      cmd="${inputs} ${mapping} -c:v copy -c:a copy -c:s copy -f matroska ${metadata} -disposition:s:${eng_idx} default \"${TMPVID}\" -y"
      ;;
    mp4|m4v)
      cmd="${inputs} ${mapping} -c:v copy -c:a copy -c:s mov_text -f mp4 ${metadata} -disposition:s:${eng_idx} default \"${TMPVID}\" -y"
      ;;
    mkv)
      cmd="${inputs} ${mapping} -c copy -f matroska ${metadata} -disposition:s:${eng_idx} default \"${TMPVID}\" -y"
      ;;
    *)
      show_error "${ext} files are not supported."
      exit 3
  esac
  echo "${cmd}"
}

function backup_files {
  local backupdir
  local subdir
  local subext
  local sub

  backupdir="backup_$(date +%Y%m%d-%H%M%S)"
  mkdir -p "${backupdir}"

  mv "${IN}" "${backupdir}/${IN}"
  for sub in "${SUBLIST[@]}"; do
    subdir="$(dirname "${sub}")"
    subext=${sub##*.}
    if ! [[ "${subdir}" = "." ]]; then
      mkdir -p "${backupdir}/${subdir}"
    fi
    mv "${sub}" "${backupdir}/${subdir}/"
    if [[ "${subext}" = sub ]]; then
      if [ -f "${sub%.*}.idx" ]; then
        mv "${sub%.*}.idx" "${subdir}/${backupdir}"
      fi
    fi
  done

  if [ -d Subs/ ]; then
    rmdir Subs/
  fi
}

#
# Main
#

detect_subs "${NAME}"
make_cmd "${IN}"
eval "$(make_cmd "${IN}")"
backup_files
mv "${TMPVID}" "${NAME}.${EXTENSION}"
sync
