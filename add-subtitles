#! /bin/bash
set -Eeuo pipefail
source globals
source langs

! check_command ffmpeg iconv enconv && exit 3

#
# Globals
#

function convert_charset {
  local tmp
  local encoding

  if [[ "${1,,}" =~ belarusian ]]; then
    enconv -L belarusian "${1}" -x utf-8
  elif [[ "${1,,}" =~ bulgarian ]]; then
    enconv -L bulgarian "${1}" -x utf-8
  elif [[ "${1,,}" =~ czech ]]; then
    enconv -L czech "${1}" -x utf-8
  elif [[ "${1,,}" =~ estonian ]]; then
    enconv -L estonian "${1}" -x utf-8
  elif [[ "${1,,}" =~ croatian ]]; then
    enconv -L croatian "${1}" -x utf-8
  elif [[ "${1,,}" =~ hungarian ]]; then
    enconv -L hungarian "${1}" -x utf-8
  elif [[ "${1,,}" =~ lithuanian ]]; then
    enconv -L lithuanian "${1}" -x utf-8
  elif [[ "${1,,}" =~ latvian ]]; then
    enconv -L latvian "${1}" -x utf-8
  elif [[ "${1,,}" =~ polish ]]; then
    enconv -L polish "${1}" -x utf-8
  elif [[ "${1,,}" =~ russian ]]; then
    enconv -L russian "${1}" -x utf-8
  elif [[ "${1,,}" =~ slovak ]]; then
    enconv -L slovak "${1}" -x utf-8
  elif [[ "${1,,}" =~ slovene ]] || [[ "${1,,}" =~ slovenian ]]; then
    enconv -L slovene "${1}" -x utf-8
  elif [[ "${1,,}" =~ ukranian ]]; then
    enconv -L ukranian "${1}" -x utf-8
  elif [[ "${1,,}" =~ chinese ]]; then
    enconv -L chinese "${1}" -x utf-8
  else
    tmp="$(mktemp)"
    encoding="$(file -b --mime-encoding "$1")"
    case "${encoding}" in
      unknown-8bit)
        iconv -f cp1252 -t "utf-8" "${1}" > "${tmp}" && \
          mv "${tmp}" "${1}"
        ;;
      *)
        iconv -f "${encoding}" -t "utf-8" "${1}" > "${tmp}" && \
          mv "${tmp}" "${1}"
        ;;
    esac
  fi
  sync
}

function get_language {
  local in
  local name
  local ext="${EXTENSION}"
  in="$(basename "${1}")"
  name="${in%.*}"

  # Single subtitles are usually English, so just return 'eng' if the video and
  # subtitle file names are the same.
  if [[ "${NAME}" = "${name}" ]]; then
    echo "${LANG_DEFAULT}"
    show_warning "assuming ${in@Q} language is ${LANG_DEFAULT@Q}" >&2
    return
  fi

  # Detect language from the file name. Will fail if a language is in the
  # title...
  for lang in "${!ISO_639_2[@]}"; do
    if [[ "${name,,}" =~ ${ISO_639_2[${lang}],,}$ ]]; then
      echo "${lang}"
      return
    fi
  done

  # If language not found, try to parse three-character strings as a fallback.
  local end
  end="$(echo "${name,,}" | \
         sed -E -e "s/[\ -_\]sdh$|[\ -_\]hi$//g" | grep -o '[^\ ]*$')"
  for lang in "${!ISO_639_2[@]}"; do
    if [[ "${end,,}" =~ ${lang,,}$ ]] || [[ "${end,,}" =~ ${ISO_639_2[${lang}],,}$ ]]; then
      echo "${lang}"
      return
    fi
  done

  # Now, try parsing two-character strings.
  for lang in "${!ISO_639_1[@]}"; do
    if [[ "${name,,}" =~ ${lang,,}$ ]]; then
      if [[ "${lang}" = br ]]; then
        lang="pt-br"
      fi
      # MP4 containers don't support ISO-639-1 codes, so map the 2-letter code
      # to the 3-letter ISO-639-2 one.
      if [[ "${EXTENSION}" = mp4 ]]; then
        for lang2 in "${!ISO_639_2[@]}"; do
          if [[ "${ISO_639_1[${lang}]}" = "${ISO_639_2[${lang2}]}" ]]; then
            echo "${lang2}"
            return
          fi
        done
      else
        echo "${lang}"
        return
      fi
    fi
  done

  show_warning "${in@Q} defaulting to ${LANG_DEFAULT}" >&2
  echo "${LANG_DEFAULT}"
}

function hardcode_cleanup {
  sed -i "s/\(\x92\|\x91\)/'/g" "${1}"
  sed -i "s/\(\x94\|\x93\)/\"/g" "${1}"
}

function count_subs {
  local sub_count=0
  local stream_count
  local codec_type

  stream_count="$(ffprobe -v error -show_format file:"${IN}" | \
                  sed -n "s/nb_streams=\([0-9]\+\)/\1/p" 2>/dev/null)"
  stream_count="$((stream_count - 1))"
  for idx in $(seq 0 "${stream_count}"); do
    codec_type="$(ffprobe -v error -show_entries stream -select_streams "${idx}" file:"${IN}" | \
                  sed -n "s/^codec_type=\(.*\)/\1/p")"
    if [[ "${codec_type}" = subtitle ]]; then
      sub_count="$((sub_count + 1))"
    fi
  done

  echo "${sub_count}"
}

function find_subs {
  local subext
  local encoding
  local sub
  local subdir="Subs"
  local file

  while read -r file; do
    if [ -f "${file}" ]; then
      subext=${file##*.}
      case "${subext}" in
        ssa|ass|srt|sup)
          encoding="$(file -b --mime-encoding "$file")"
          if ! [[ "${encoding}" = "utf-8" ]]; then
            show_info "INFO: Converting ${file} encoding from ${encoding} to UTF-8."
            convert_charset "${file}"
          fi
          SUBLIST+=("${file}")
          ;;
        sub)
          if [ -f "${file%.*}.idx" ]; then
            IS_IMGSUB=true
          fi
          SUBLIST+=("${file}")
          ;;
        avi|m4v|mp4|mkv|webm|idx)
          ;;
        *)
          show_warning "WARNING: ${file} not supported. Skipping..."
          ;;
      esac
    fi
  done <<< "$(ls -v "${1}"*)"

  if [ -d "${subdir}" ]; then
    while read -r file; do
      if [ -f "${subdir}/${file}" ]; then
        subext=${file##*.}
        case "${subext}" in
          ass|srt|sup)
            encoding="$(file -b --mime-encoding "${subdir}/$file")"
            if ! [[ "${encoding}" = "utf-8" ]]; then
              show_info "INFO: Converting ${file} encoding from ${encoding} to utf-8."
              convert_charset "${subdir}/${file}"
            fi
            remove_ads "${subdir}/${file}"
            SUBLIST+=("${subdir}/${file}")
            ;;
          sub)
            if [ -f "${subdir}/${file%.*}.idx" ]; then
              IS_IMGSUB=true
            fi
            SUBLIST+=("${subdir}/${file}")
            ;;
          avi|m4v|mp4|mkv|webm|idx)
            ;;
          *)
            show_warning "WARNING: ${file} not supported. Skipping..."
            ;;
        esac
      fi
    done <<< "$(ls -v "Subs/")"
  fi

  for sub in "${SUBLIST[@]}"; do
    show_listitem "${sub}"
  done
}

function make_cmd {
  local ext
  local sub
  local subidx
  local subname
  local subext
  local inputs
  local mapping
  local metadata
  local disposition
  local file_count
  local stream_count
  local lang
  local default_idx=-1 # idx of stream to set as the default

  inputs="-i file:${1@Q}"
  file_count=1
  if [[ "${FORCE}" = false ]]; then
    mapping="-map 0"
    stream_count="$(count_subs)"
  else
    mapping="-map 0:v -map 0:a"
    stream_count=0
  fi
  metadata="-sub_charenc UTF-8"

  if [[ "${#SUBLIST[@]}" = 1 ]]; then
    sub="${SUBLIST[0]}"
    subext="${sub##*.}"
    if [[ "${subext}" = "sub" ]]; then
      subidx="${sub%.*}.idx"
      inputs="${inputs} -i file:${subidx@Q} -i file:${sub@Q}"
    else
      inputs="${inputs} -i file:${sub@Q}"
    fi
    mapping="${mapping} -map ${file_count}:s"
    metadata="${metadata} -metadata:s:s:${stream_count} language=${LANG_DEFAULT}"
    metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[${LANG_DEFAULT}]}\""
  elif [[ "${#SUBLIST[@]}" -gt 1 ]]; then
    for sub in "${SUBLIST[@]}"; do
      subname="${sub%.*}"
      subext="${sub##*.}"
      subidx="${sub%.*}.idx"
      if [[ "${subext}" = "sub" ]] && [ -f "${subidx}" ]; then
        inputs="${inputs} -i file:${subidx@Q} -i file:${sub@Q}"
        mapping="${mapping} -map ${file_count}:s -map $((file_count + 1)):s"
        if [[ "${sub,,}" =~ ${ISO_639_2[${LANG_DEFAULT}],,} ]] && \
           [[ "${default_idx}" == -1 ]]; then
          default_idx="${stream_count}"
        fi
        lang="$(get_language "${sub}")"
        # add suffix if present (e.g. SDH for ambient sounds in the subtitles)
        if [[ "${subname,,}" =~ sdh$ ]] || [[ "${subname,,}" =~ hi$ ]]; then
          # metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}(sdh)\""
          metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
          if [ "${#lang}" = 3 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\" -metadata:s:s:${stream_count} title=\"${ISO_639_2[$lang]} SDH\""
          elif [ "${#lang}" = 2 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\" -metadata:s:s:${stream_count} title=\"${ISO_639_1[$lang]} SDH\""
          fi
        else
          # set default_idx to avoid ambient sounds in the default subtitles
          if [[ "${lang}" = "${LANG_DEFAULT}" ]] && \
             [[ "${default_idx}" == -1 ]]; then
            default_idx="${stream_count}"
          fi
          metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
          if [ "${#lang}" = 3 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\""
          elif [ "${#lang}" = 2 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\""
          fi
        fi
        file_count=$((file_count + 2))
        stream_count=$((stream_count + 1))
      else
        inputs="${inputs} -i file:${sub@Q}"
        mapping="${mapping} -map ${file_count}:s"
        lang="$(get_language "${sub}")"
        # add suffix if present (e.g. SDH for ambient sounds in the subtitles)
        if [[ "${subname,,}" =~ sdh$ ]] || [[ "${subname,,}" =~ hi$ ]]; then
          # metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}(sdh)\""
          metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
          if [ "${#lang}" = 3 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]} SDH\" -metadata:s:s:${stream_count} title=\"${ISO_639_2[$lang]} SDH\""
          elif [ "${#lang}" = 2 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]} SDH\" -metadata:s:s:${stream_count} title=\"${ISO_639_1[$lang]} SDH\""
          fi
        else
          # set default_idx to avoid ambient sounds in the default subtitles
          if [[ "${lang}" = "${LANG_DEFAULT}" ]] && \
             [[ "${default_idx}" == -1 ]]; then
            default_idx="${stream_count}"
          fi
          metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
          if [ "${#lang}" = 3 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\""
          elif [ "${#lang}" = 2 ]; then
            metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\""
          fi
        fi
        file_count=$((file_count + 1))
        stream_count=$((stream_count + 1))
      fi
    done
  fi

  if [[ "${NOSUB}" = false ]]; then
    if ! [[ "${default_idx}" == -1 ]]; then
      disposition="-disposition:s:${default_idx} default"
    else
      disposition=""
    fi
  else
    disposition="-default_mode infer_no_subs -disposition:s -default"
  fi

  if [ -n "${CONTAINER}" ]; then
    ext="${CONTAINER}"
  else
    ext="${EXTENSION}"
  fi

  case ${ext} in
    avi)
      # AVI only supports embedding XSub files, so just use a Matroska
      # container instead.
      CONTAINER="mkv"
      show_warning "Re-muxing AVI to Matroska container." >&2
      CMD="ffmpeg -fflags +genpts ${inputs} ${mapping} ${disposition} -c copy -f matroska ${metadata} ${TMPVID@Q} -y"
      ;;
    mp4|m4v)
      # MP4 can have issues embedding image-based subtitles, so convert to
      # Matroska.
      if "${IS_IMGSUB}"; then
        CONTAINER="mkv"
        show_warning "Image subtitles detected. Re-muxing to Matroska container." >&2
        CMD="ffmpeg -fflags +genpts ${inputs} ${mapping} ${disposition} -c copy -f matroska ${metadata} ${TMPVID@Q} -y"
      else
        CMD="ffmpeg ${inputs} ${mapping} ${disposition} -c:v copy -c:a copy -c:s mov_text -f mp4 ${metadata} ${TMPVID@Q} -y"
      fi
      ;;
    mkv)
      CMD="ffmpeg ${inputs} ${mapping} ${disposition} -c copy -f matroska ${metadata} ${TMPVID@Q} -y"
      ;;
    *)
      show_error "ERROR: ${ext} files are not supported."
      exit 3
  esac
}

function backup_files {
  local backupdir
  local infile
  local indir
  local subfile
  local subdir
  local subext
  local sub

  infile="$(basename "${IN}")"
  indir="$(dirname "${IN}")"
  backupdir="${indir}/backup_$(date +%Y%m%d-%H%M%S)"
  mkdir -p "${backupdir}"

  mv "${IN}" "${backupdir}/${infile}"
  for sub in "${SUBLIST[@]}"; do
    subdir="$(dirname "${sub}")"
    subfile="$(basename "${sub}")"
    subext=${sub##*.}
    if ! [[ "${subdir}" = "${indir}" ]]; then
      mkdir -p "${backupdir}/${subdir}"
    else
      subdir="."
    fi
    mv "${sub}" "${backupdir}/${subdir}/${subfile}"
    if [[ "${subext}" = sub ]]; then
      if [ -f "${sub%.*}.idx" ]; then
        mv "${sub%.*}.idx" "${backupdir}/${subdir}/${subfile%.*}.idx"
      fi
    fi
  done

  if [ -d "${indir}/Subs" ]; then
    rmdir "${indir}/Subs"
  fi
}

#
# Main
#

OPTIONS=c:fl:n
LONGOPTIONS=container:,force,language:,nodefault
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "${0}" -- "${@}")
eval set -- "${PARSED}"

FORCE=false
NOSUB=false
CONTAINER=
CMD=
IS_IMGSUB=false
LANG_DEFAULT=eng # needs to be 3-letter code (lower case)
while [ ${#} -ge 1 ]; do
  case ${1} in
    -c|--container)
      CONTAINER="${2}"
      shift 2
      ;;
    -f|--force)
      FORCE=true
      shift 1
      ;;
    -n|--nodefault)
      NOSUB=true
      shift 1
      ;;
    -l|--language)
      LANG_DEFAULT="${2}"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR: invalid flag."
      exit 3
      ;;
  esac
done

if [[ ${#} -ne 1 ]]; then
  show_error "ERROR: please specify 1 input file."
  exit 3
fi

if ! [[ -f "${1}" ]]; then
  show_error "ERROR: input ${1} not a file."
  exit 3
fi

IN="${1}"
NAME="${1%.*}"
EXTENSION="${1##*.}"
TMPVID="$(mktemp)"
SUBLIST=()

trap 'rm "${TMPVID}"; exit' INT TERM ERR

find_subs "${NAME}"
make_cmd "${IN}"
show_header "${CMD}"
eval "${CMD}"
backup_files
if [ -n "${CONTAINER}" ]; then
  mv "${TMPVID}" "${NAME}.${CONTAINER}"
else
  mv "${TMPVID}" "${NAME}.${EXTENSION}"
fi
sync
