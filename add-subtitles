#! /bin/bash
set -Eeuo pipefail
source globals
source langs

! check_command ffmpeg iconv enconv chardetect bc && exit 3

#
# Globals
#

function convert_charset {
  local tmp
  local res
  local encoding
  local confidence

  tmp="$(mktemp)"
  res="$(chardetect "${1}")"
  confidence="$(echo "${res}" | sed -n "s/^${1}:\ .*with confidence \(.*\)$/\1/p")"

  # If chardetect confidence is too low, use file --mime-encoding to guess
  # character map instead.
  if [ "$(echo "${confidence} > .9" | bc -l)" -eq 1 ]; then
    encoding="$(echo "${res}" | sed -n "s/^${1}:\ \([A-Za-z0-9\-]\+\) with .*/\1/p")"
  else
    show_warning "WARNING: Using fallback to get character encoding for ${1}."
    encoding="$(file -b --mime-encoding "${1}")"
  fi

  # Convert charset to UTF-8, if needed.
  case "${encoding}" in
    utf-8|UTF-8|ascii|us-ascii)
      # No need to do anything.
      ;;
    utf-8-sig|UTF-8-SIG)
      # Use sed to delete the byte-order mark (BOM)
      sed -i 's/\xef\xbb\xbf//' "${1}"
      ;;
    unknown-8bit)
      show_warning "WARNING: Unknown character encoding for ${1}. Skipping..."
      ;;
    *)
      show_info "INFO: Converting ${file} from ${encoding} to UTF-8." >&2
      iconv -f "${encoding}" -t utf-8 "${1}" > "${tmp}"
      mv "${tmp}" "${1}"
      ;;
  esac

  sync
}

function get_language {
  local in
  local name
  local end
  local iso_639_1_code
  local iso_639_1_name
  local iso_639_2_code
  local iso_639_2_name
  local iso_639_1_iso_3166_1_code
  local iso_639_1_iso_3166_1_code_strip
  local iso_639_1_iso_3166_1_name

  in="$(basename "${1}")"
  name="${in%.*}"

  # Single subtitles are usually English, so just return 'eng' if the video and
  # subtitle file names are the same.
  if [[ "${NAME}" = "${name}" ]]; then
    show_warning "assuming ${in@Q} language is ${LANG_DEFAULT@Q}" >&2
    echo "${LANG_DEFAULT}"
    return
  fi

  # Parse the end of the file name for three-character strings.
  end="$(echo "${name,,}" | \
         sed -E -e "s/[\ -_]sdh$|[\ -_]hi$//g" | \
         grep -o '[^\ ]*$')"
  for iso_639_2_code in "${!ISO_639_2[@]}"; do
    iso_639_2_name="${ISO_639_2[${iso_639_2_code}]}"
    if [[ "${end,,}" = "${iso_639_2_code,,}" ]] || \
       [[ "${end,,}" = "${iso_639_2_name,,}" ]]; then
      echo "${iso_639_2_code}"
      return
    fi
  done

  # Now, try parsing two-character strings.
  for iso_639_1_code in "${!ISO_639_1[@]}"; do
    if [[ "${end,,}" = "${iso_639_1_code,,}" ]]; then
      iso_639_1_name="${ISO_639_1[${iso_639_1_code}]}"

      # MP4 containers don't support ISO-639-1 codes, so map the 2-letter code
      # to the 3-letter ISO-639-2 one.
      if [[ "${EXTENSION}" = mp4 ]]; then
        for iso_639_2_code in "${!ISO_639_2[@]}"; do
          iso_639_2_name="${ISO_639_2[${iso_639_2_code}]}"
          if [[ "${iso_639_1_name}" = "${iso_639_2_name}" ]]; then
            echo "${iso_639_2_code}"
            return
          fi
        done
      else
        echo "${iso_639_1_code}"
        return
      fi
    fi
  done

  # Lastly, try parsing two-character strings + two-character country codes.
  for iso_639_1_iso_3166_1_code in "${!ISO_639_1_ISO_3166_1[@]}"; do
    iso_639_1_iso_3166_1_code_strip="${iso_639_1_iso_3166_1_code/[-_]/}"
    iso_639_1_iso_3166_1_name="${ISO_639_1_ISO_3166_1[${iso_639_1_iso_3166_1_code}]}"
    if [[ "${end,,}" = "${iso_639_1_iso_3166_1_code,,}" ]] || \
       [[ "${end,,}" = "${iso_639_1_iso_3166_1_code_strip,,}" ]] || \
       [[ "${end,,}" = "${iso_639_1_iso_3166_1_name,,}" ]]; then
      echo "${iso_639_1_iso_3166_1_code}"
      return
    fi
  done

  show_warning "${in@Q} defaulting to ${LANG_DEFAULT}" >&2
  echo "${LANG_DEFAULT}"
}

function hardcode_cleanup {
  sed -i "s/\(\x92\|\x91\)/'/g" "${1}"
  sed -i "s/\(\x94\|\x93\)/\"/g" "${1}"
}

function count_subs {
  local sub_count=0
  local stream_count
  local codec_type

  stream_count="$(ffprobe -v error -show_format file:"${IN}" | \
                  sed -n "s/nb_streams=\([0-9]\+\)/\1/p" 2>/dev/null)"
  stream_count="$((stream_count - 1))"
  for idx in $(seq 0 "${stream_count}"); do
    codec_type="$(ffprobe -v error -show_entries stream -select_streams "${idx}" file:"${IN}" | \
                  sed -n "s/^codec_type=\(.*\)/\1/p")"
    if [[ "${codec_type}" = subtitle ]]; then
      sub_count="$((sub_count + 1))"
    fi
  done

  echo "${sub_count}"
}

function find_subs {
  local subext
  local encoding
  local sub
  local subdir="Subs"
  local file

  while read -r file; do
    if [ -f "${file}" ]; then
      subext=${file##*.}
      case "${subext}" in
        ssa|ass|srt|sup|smi)
          convert_charset "${file}"
          SUBLIST+=("${file}")
          ;;
        sub)
          if [ -f "${file%.*}.idx" ]; then
            IS_IMGSUB=true
          fi
          SUBLIST+=("${file}")
          ;;
        avi|m4v|mp4|mkv|webm|idx)
          ;;
        *)
          show_warning "WARNING: ${file} not supported. Skipping..."
          ;;
      esac
    fi
  done <<< "$(ls -v "${1}"*)"

  if [ -d "${subdir}" ]; then
    while read -r file; do
      if [ -f "${subdir}/${file}" ]; then
        subext=${file##*.}
        case "${subext}" in
          ssa|ass|srt|sup|smi)
            convert_charset "${subdir}/${file}"
            SUBLIST+=("${subdir}/${file}")
            ;;
          sub)
            if [ -f "${subdir}/${file%.*}.idx" ]; then
              IS_IMGSUB=true
            fi
            SUBLIST+=("${subdir}/${file}")
            ;;
          avi|m4v|mp4|mkv|webm|idx)
            ;;
          *)
            show_warning "WARNING: ${file} not supported. Skipping..."
            ;;
        esac
      fi
    done <<< "$(ls -v "Subs/")"
  fi

  for sub in "${SUBLIST[@]}"; do
    show_listitem "${sub}"
  done
}

function get_codec {
  local fstring
  fstring="$(ffprobe -v error \
               -show_entries stream=codec_name -of compact=p=0:nk=1 file:"${1}")"
  echo "${fstring}"
}

function make_cmd {
  local ext
  local sub
  local subidx
  local subname
  local subext
  local codec
  local inputs
  local mapping
  local metadata
  local copy
  local disposition
  local file_count
  local stream_count
  local lang
  local default_idx=-1 # idx of stream to set as the default

  if [ -n "${CONTAINER}" ]; then
    ext="${CONTAINER}"
  else
    ext="${EXTENSION}"
  fi

  inputs="-i file:${1@Q}"
  file_count=1
  mapping="-map_chapters 0 -map_metadata 0"
  if [[ "${FORCE}" = false ]]; then
    mapping="${mapping} -map 0"
    stream_count="$(count_subs)"
  else
    mapping="${mapping} -map 0:v -map 0:a"
    stream_count=0
  fi
  metadata="-sub_charenc UTF-8"

  copy="-c:v copy -c:a copy"
  if [ "${stream_count}" -gt 0 ]; then
    copy="${copy} $(printf ' -c:s:%s copy' $(seq 0 $((stream_count-1))))"
  fi

  for sub in "${SUBLIST[@]}"; do
    subname="${sub%.*}"
    subext="${sub##*.}"
    subidx="${sub%.*}.idx"
    if [[ "${subext}" = "sub" ]] && [ -f "${subidx}" ]; then
      inputs="${inputs} -i file:${subidx@Q} -i file:${sub@Q}"
      mapping="${mapping} -map ${file_count}:s -map $((file_count + 1)):s"
      if [[ "${sub,,}" =~ ${ISO_639_2[${LANG_DEFAULT}],,} ]] && \
         [[ "${default_idx}" == -1 ]]; then
        default_idx="${stream_count}"
      fi
      lang="$(get_language "${sub}")"
      codec="$(get_codec "${sub}")"

      # add suffix if present (e.g. SDH for ambient sounds in the subtitles)
      if [[ "${subname,,}" =~ ( |-|_|\.)sdh$ ]] || \
         [[ "${subname,,}" =~ ( |-|_|\.)hi$ ]]; then
        metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
        if [ "${#lang}" = 3 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\""
          metadata="${metadata} -metadata:s:s:${stream_count} title=\"${ISO_639_2[$lang]} SDH\""
        elif [ "${#lang}" = 2 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\""
          metadata="${metadata} -metadata:s:s:${stream_count} title=\"${ISO_639_1[$lang]} SDH\""
        elif [ "${#lang}" = 5 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1_ISO_3166_1[${lang}]}\""
          metadata="${metadata} -metadata:s:s:${stream_count} title=\"${ISO_639_1_ISO_3166_1[${lang}]} SDH\""
        fi
      else
        # set default_idx to avoid ambient sounds in the default subtitles
        if [[ "${lang}" = "${LANG_DEFAULT}" ]] && \
           [[ "${default_idx}" == -1 ]]; then
          default_idx="${stream_count}"
        fi
        metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
        if [ "${#lang}" = 3 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\""
        elif [ "${#lang}" = 2 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\""
        elif [ "${#lang}" = 5 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1_ISO_3166_1[${lang}]}\""
        fi
      fi

      # set output subtitle codec
      if [[ "${codec}" = sami ]]; then
        case "${ext}" in
          mp4)
            copy="${copy} -c:s:${stream_count} mov_text"
            ;;
          mkv)
            copy="${copy} -c:s:${stream_count} subrip"
            ;;
          *)
            copy="${copy} -c:s:${stream_count} copy"
            ;;
          esac
      elif [[ "${codec}" = subrip ]] && [[ "${ext}" = mp4 ]]; then
        copy="${copy} -c:s:${stream_count} mov_text"
      else
        copy="${copy} -c:s:${stream_count} copy"
      fi

      # increment counters
      file_count=$((file_count + 2))
      stream_count=$((stream_count + 1))
    else
      inputs="${inputs} -i file:${sub@Q}"
      mapping="${mapping} -map ${file_count}:s"
      lang="$(get_language "${sub}")"
      codec="$(get_codec "${sub}")"

      # add suffix if present (e.g. SDH for ambient sounds in the subtitles)
      if [[ "${subname,,}" =~ ( |-|_|\.)sdh$ ]] || \
         [[ "${subname,,}" =~ ( |-|_|\.)hi$ ]]; then
        metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
        if [ "${#lang}" = 3 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\""
          metadata="${metadata} -metadata:s:s:${stream_count} title=\"${ISO_639_2[$lang]} SDH\""
        elif [ "${#lang}" = 2 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\""
          metadata="${metadata} -metadata:s:s:${stream_count} title=\"${ISO_639_1[$lang]} SDH\""
        elif [ "${#lang}" = 5 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1_ISO_3166_1[${lang}]}\""
          metadata="${metadata} -metadata:s:s:${stream_count} title=\"${ISO_639_1_ISO_3166_1[${lang}]} SDH\""
        fi
      else
        # set default_idx to avoid ambient sounds in the default subtitles
        if [[ "${lang}" = "${LANG_DEFAULT}" ]] && \
           [[ "${default_idx}" == -1 ]]; then
          default_idx="${stream_count}"
        fi
        metadata="${metadata} -metadata:s:s:${stream_count} language=\"${lang}\""
        if [ "${#lang}" = 3 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_2[$lang]}\""
        elif [ "${#lang}" = 2 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1[$lang]}\""
        elif [ "${#lang}" = 5 ]; then
          metadata="${metadata} -metadata:s:s:${stream_count} handler=\"${ISO_639_1_ISO_3166_1[${lang}]}\""
        fi
      fi

      # set output subtitle codec
      if [[ "${codec}" = sami ]]; then
        case "${ext}" in
          mp4)
            copy="${copy} -c:s:${stream_count} mov_text"
            ;;
          mkv)
            copy="${copy} -c:s:${stream_count} subrip"
            ;;
          *)
            copy="${copy} -c:s:${stream_count} copy"
            ;;
          esac
      elif [[ "${codec}" = subrip ]] && [[ "${ext}" = mp4 ]]; then
        copy="${copy} -c:s:${stream_count} mov_text"
      else
        copy="${copy} -c:s:${stream_count} copy"
      fi

      # increment counters
      file_count=$((file_count + 1))
      stream_count=$((stream_count + 1))
    fi
  done

  if [[ "${NOSUB}" = false ]]; then
    if ! [[ "${default_idx}" == -1 ]]; then
      disposition="-disposition:s:${default_idx} default"
    else
      disposition=""
    fi
  else
    disposition="-default_mode infer_no_subs -disposition:s -default"
  fi

  case ${ext} in
    avi)
      # AVI only supports embedding XSub files, so just use a Matroska
      # container instead.
      CONTAINER="mkv"
      show_warning "Re-muxing AVI to Matroska container." >&2
      CMD="ffmpeg -fflags +genpts ${inputs} ${mapping} ${disposition} ${copy} -f matroska ${metadata} ${TMPVID@Q} -y"
      ;;
    mp4|m4v)
      # MP4 can have issues embedding image-based subtitles, so convert to
      # Matroska.
      if "${IS_IMGSUB}"; then
        CONTAINER="mkv"
        show_warning "Image subtitles detected. Re-muxing to Matroska container." >&2
        CMD="ffmpeg -fflags +genpts ${inputs} ${mapping} ${disposition} ${copy} -f matroska ${metadata} ${TMPVID@Q} -y"
      else
        CMD="ffmpeg ${inputs} ${mapping} ${disposition} ${copy} -f mp4 ${metadata} ${TMPVID@Q} -y"
      fi
      ;;
    mkv)
      CMD="ffmpeg ${inputs} ${mapping} ${disposition} ${copy} -f matroska ${metadata} ${TMPVID@Q} -y"
      ;;
    *)
      show_error "ERROR: ${ext} files are not supported."
      exit 3
  esac
}

function backup_files {
  local backupdir
  local infile
  local indir
  local subfile
  local subdir
  local subext
  local sub

  infile="$(basename "${IN}")"
  indir="$(dirname "${IN}")"
  backupdir="${indir}/backup_$(date +%Y%m%d-%H%M%S)"
  mkdir -p "${backupdir}"

  mv "${IN}" "${backupdir}/${infile}"
  for sub in "${SUBLIST[@]}"; do
    subdir="$(dirname "${sub}")"
    subfile="$(basename "${sub}")"
    subext=${sub##*.}
    if ! [[ "${subdir}" = "${indir}" ]]; then
      mkdir -p "${backupdir}/${subdir}"
    else
      subdir="."
    fi
    mv "${sub}" "${backupdir}/${subdir}/${subfile}"
    if [[ "${subext}" = sub ]]; then
      if [ -f "${sub%.*}.idx" ]; then
        mv "${sub%.*}.idx" "${backupdir}/${subdir}/${subfile%.*}.idx"
      fi
    fi
  done

  if [ -d "${indir}/Subs" ]; then
    rmdir "${indir}/Subs"
  fi
}

#
# Main
#

OPTIONS=c:fl:n
LONGOPTIONS=container:,force,language:,nodefault
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "${0}" -- "${@}")
eval set -- "${PARSED}"

FORCE=false
NOSUB=false
CONTAINER=
CMD=
IS_IMGSUB=false
LANG_DEFAULT=eng # needs to be 3-letter code (lower case)
while [ ${#} -ge 1 ]; do
  case ${1} in
    -c|--container)
      CONTAINER="${2}"
      shift 2
      ;;
    -f|--force)
      FORCE=true
      shift 1
      ;;
    -n|--nodefault)
      NOSUB=true
      shift 1
      ;;
    -l|--language)
      LANG_DEFAULT="${2}"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR: invalid flag."
      exit 3
      ;;
  esac
done

if [[ ${#} -ne 1 ]]; then
  show_error "ERROR: please specify 1 input file."
  exit 3
fi

if ! [[ -f "${1}" ]]; then
  show_error "ERROR: input ${1} not a file."
  exit 3
fi

IN="${1}"
NAME="${1%.*}"
EXTENSION="${1##*.}"
TMPVID="$(mktemp)"
SUBLIST=()

trap 'rm "${TMPVID}"; exit' INT TERM ERR

find_subs "${NAME}"
make_cmd "${IN}"
show_header "${CMD}"
eval "${CMD}"
backup_files
if [ -n "${CONTAINER}" ]; then
  mv "${TMPVID}" "${NAME}.${CONTAINER}"
else
  mv "${TMPVID}" "${NAME}.${EXTENSION}"
fi
sync
