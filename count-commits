#! /bin/bash
set -euo pipefail
source globals

! check_command awk git && exit 3


#
# Functions
#

get_count() {
  local dir
  local cmd
  dir=${1%/*}

  # Git will traverse the entire from HEAD to the first commit where the
  # committer or the author date falls outside the range. This can caused
  # unexpected behavior for merge / rebase / fixup commits, as the committer
  # and author dates will likely not match.
  cmd="git -C ${dir@Q} rev-list --count --branches"
  if [ -n "${AUTHOR}" ] || [ -n "${EMAIL}" ]; then
    cmd="${cmd} --author=^${AUTHOR:-.*}\ \<${EMAIL:-.*}\>$"
  fi
  if [ -n "${SINCE}" ]; then
    cmd="${cmd} --since=$(date -d "${SINCE}" +%s)"
  fi
  if [ -n "${UNTIL}" ]; then
    cmd="${cmd} --until=$(date -d "${UNTIL}" +%s)"
  fi
  eval "${cmd}"
}
export -f get_count

print_usage() {
  show_header "Usage: count-commits"
  echo
  show_listitem "  -a|--author  <author>"
  show_listitem "  -e|--email   <email>"
  show_listitem "  -s|--since   <time>"
  show_listitem "  -u|--until   <time>"
  show_listitem "  -h|--help    print (this) help message"
  echo
  show_listitem "<author> = commit author"
  show_listitem "<email>  = committer/author email address"
  show_listitem \
    "<time>   = string (e.g. 1week, 2years, now), passed to 'date' from coreutils"
}

parse_date() {
  local string_array
  local string_array_part2
  local item
  local item2
  local digits
  local suffix
  local prefix
  digits=
  suffix=
  prefix=
  IFS=' ' read -r -a string_array <<< "${1}"
  for item in "${string_array[@]}"; do
    IFS='-' read -r -a string_array_part2 <<< "${item}"
    for item2 in "${string_array_part2[@]}"; do
      case "${item2}" in
        one|1)
          digits=${digits}+1
          ;;
        two|2)
          digits=${digits}+2
          ;;
        three|3)
          digits=${digits}+3
          ;;
        four|4)
          digits=${digits}+4
          ;;
        five|5)
          digits=${digits}+5
          ;;
        six|6)
          digits=${digits}+6
          ;;
        seven|7)
          digits=${digits}+7
          ;;
        eight|8)
          digits=${digits}+8
          ;;
        nine|9)
          digits=${digits}+9
          ;;
        ten|10)
          digits=${digits}+10
          ;;
        eleven|11)
          digits=${digits}+11
          ;;
        twelve|12)
          digits=${digits}+12
          ;;
        thirteen|13)
          digits=${digits}+13
          ;;
        fourteen|14)
          digits=${digits}+14
          ;;
        fifteen|15)
          digits=${digits}+15
          ;;
        sixteen|16)
          digits=${digits}+16
          ;;
        seventeen|17)
          digits=${digits}+17
          ;;
        eighteen|18)
          digits=${digits}+18
          ;;
        nineteen|19)
          digits=${digits}+19
          ;;
        twenty|20)
          digits=${digits}+20
          ;;
        thirty|30)
          digits=${digits}+30
          ;;
        forty|40)
          digits=${digits}+40
          ;;
        fifty|50)
          digits=${digits}+50
          ;;
        sixty|60)
          digits=${digits}+60
          ;;
        seventy|70)
          digits=${digits}+70
          ;;
        eighty|80)
          digits=${digits}+80
          ;;
        ninety|90)
          digits=${digits}+90
          ;;
        hundred|100)
          digits="${digits}*100"
          ;;
        thousand|1000|1,000)
          digits="${digits}*1000"
          ;;
        million|1000000|1,000,000)
          digits="${digits}*1000000"
          ;;
      ago)
        prefix="-"
        ;;
      *)
        suffix="${suffix:+${suffix} }${item2}"
        ;;
      esac
    done
  done
  [ -n "${digits}" ] && digits="$((digits))"
  echo "${prefix}${digits:+${digits} }${suffix}"
}

#
# Main
#

SINCE=
UNTIL=
AUTHOR=
EMAIL=

OPTIONS=ha:d:e:s:u:
LONGOPTIONS=help,author:,depth:,email:,since:,until:
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "${0}" -- "${@}")
eval set -- "${PARSED}"

while [ ${#} -ge 1 ]; do
  case "${1}" in
    -a|--author)
      AUTHOR=${2}
      shift 2
      ;;
    -e|--email)
      EMAIL=${2}
      shift 2
      ;;
    -d|--depth)
      DEPTH=${2}
      shift 2
      ;;
    -s|--since)
      SINCE="$(parse_date "${2}")"
      shift 2
      ;;
    -u|--until)
      UNTIL="$(parse_date "${2}")"
      shift 2
      ;;
    -h|--help)
      print_usage
      exit
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR: option ${1@Q} unrecognized. Exiting."
      exit 3
      ;;
  esac
done

export AUTHOR
export EMAIL
export SINCE
export UNTIL

projectdir="${projectdir:-${HOME}}"
PROJECTDIR=("${@:-${projectdir}}")

if [ ${#} -eq 1 ] && git -C "${1}" log >/dev/null 2>&1; then
  get_count "${1}" | awk '{s+=$1}END{print s}'
else
  find -L "${PROJECTDIR[@]}" ${DEPTH:+-maxdepth ${DEPTH}} -type d -name ".git" \
    -exec bash -c 'get_count "${1}"' bash {} \; | awk '{s+=$1}END{print s}'
fi
