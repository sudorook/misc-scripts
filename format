#! /bin/bash
set -eu
source globals

! check_command parallel && exit 3

function format_c() {
  local tmp
  if command -v clang-format >/dev/null; then
    tmp="$(mktemp)"
    clang-format -style=mozilla "${1}" > "${tmp}"
    mv "${tmp}" "${1}"
  else
    show_error "ERROR: 'clang-format' not installed. Exiting." >&2
    exit 3
  fi
}
export -f format_c

function format_python() {
  if command -v black >/dev/null; then
    black -q -l 79 "${1}"
  else
    show_error "ERROR: 'black' not installed. Exiting." >&2
    exit 3
  fi
}
export -f format_python

function detect_mimetype() {
  local mime
  mime="$(file -b --mime-type "${1}")"
  case "${mime}" in
    text/x-c|text/x-c++)
      if [[ "${1##*.}" != y ]] && [[ "${1##*.}" != l ]]; then
        echo c
      else
        show_warning "WARNING: ${1@Q} parsers/lexers unspported." >&2
      fi
      ;;
    text/x-script.python)
      echo python
      ;;
    *)
      show_warning "WARNING: ${1@Q} type ${mime@Q} unsupported." >&2
      ;;
  esac
}
export -f detect_mimetype

function format_wrapper() {
  local lang
  lang="$(detect_mimetype "${1}")"
  if ! [[ -v LANGUAGE ]]; then
    if [[ -z "${lang}" ]]; then
      return
    fi
  else
    if [[ "${LANGUAGE,,}" != "${lang}" ]] && ! "${FORCE}"; then
      show_warning "WARNING: ${1@Q} language and MIME type mismatch. Skipping." >&2
      return
    fi
    lang="${LANGUAGE}"
  fi

  case "${lang}" in
    c|C|c++|C++|cpp|CPP)
      format_c "${1}"
      ;;
    python|Python)
      format_python "${1}"
      ;;
    *)
      show_error "ERROR" >&2
      exit 3
      ;;
  esac

  show_success "${1@Q} done!"
}
export -f format_wrapper

function print_usage() {
  show_header   "Usage: format <file or directory> -l <lang>"
  echo
  show_listitem \
    "  -l|--language   (optional) programming language (e.g. C++, Python)"
  show_listitem \
    "  -h|--help       print (this) message"
  show_listitem \
    "  -f|--force      run formatter regardless of MIME type"
  echo
  show_info "Specify a file to format a single file. Specify a directory to
recursively format _all_ files in it. Any files without MIME type
supported by this script will be ignored."
}


#
# Main
#

FORCE=false

OPTIONS=fhl:
LONGOPTIONS=force:help,language:
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "$0" -- "$@")
eval set -- "$PARSED"

while [ $# -ge 1 ]; do
  case "$1" in
    -f|--force)
      FORCE=true
      shift
      ;;
    -l|--language)
      LANGUAGE="${2}"
      shift 2
      ;;
    -h|--help)
      print_usage
      exit
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR"
      exit 3
      ;;
  esac
done

for ITEM in "${@}"; do
  if [[ -f "${ITEM}" ]]; then
    format_wrapper "${ITEM}"
  elif [[ -d "${ITEM}" ]]; then
    if check_command parallel; then
      find "${ITEM}" -type f \
        -not \( -path "./.git*" -o \
                -path "./docs/*" -o \
                -path "*README*" -o \
                -path "*readme*" -o \
                -path "*LICENSE*" -o \
                -path "*license*" -o \
                -path "*.Rhistory" \) -print0 | \
        parallel -0 format_wrapper "{}"
    else
      find "${ITEM}" -type f \
        -not \( -path "./.git*" -o \
                -path "./docs/*" -o \
                -path "*README*" -o \
                -path "*readme*" -o \
                -path "*LICENSE*" -o \
                -path "*license*" -o \
                -path "*.Rhistory" \) \
        -exec bash -c 'format_wrapper "${1}"' bash {} \;
    fi
  else
    show_error "WARNING: ${ITEM@Q} not understood. Skipping." >&2
  fi
done
