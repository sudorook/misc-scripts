#! /bin/bash
set -eu
source globals

! check_command black clang-format parallel && exit 3

function format_c() {
  local tmp
  tmp="$(mktemp)"
  clang-format -style=mozilla "${1}" > "${tmp}"
  mv "${tmp}" "${1}"
  sync
}
export -f format_c

function format_python() {
  black -q -l 79 "${1}"
}
export -f format_python

function detect_mimetype() {
  local mime
  mime="$(file -b --mime-type "${1}")"
  case "${mime}" in
    text/x-c|text/x-c++)
      if [[ "${1##*.}" != y ]] && [[ "${1##*.}" != l ]]; then
        echo c
      else
        show_warning "WARNING: skipping ${1@Q} parser/lexer." >&2
      fi
      ;;
    text/x-script.python)
      echo python
      ;;
    *)
      show_warning "WARNING: skipping ${1@Q} type ${mime@Q}." >&2
      ;;
  esac
}
export -f detect_mimetype

function format_wrapper() {
  local lang
  lang="$(detect_mimetype "${1}")"
  if ! [[ -v LANGUAGE ]]; then
    if [[ -z "${lang}" ]]; then
      return
    fi
  else
    if [[ "${LANGUAGE,,}" != "${lang}" ]] && ! "${FORCE}"; then
      show_warning "WARNING: ${1@Q} language and MIME type mismatch. Skipping." >&2
      return
    fi
    lang="${LANGUAGE}"
  fi

  case "${lang}" in
    c|C|c++|C++|cpp|CPP)
      format_c "${1}"
      ;;
    python|Python)
      format_python "${1}"
      ;;
    *)
      show_error "ERROR" >&2
      exit 3
      ;;
  esac

  show_success "${1@Q} done!"
}
export -f format_wrapper

function print_usage() {
  show_header   "Usage: format <file or directory> -l <lang>"
  echo
  show_listitem \
    "  -l|--language   (optional) programming language (e.g. C++, Python)"
  show_listitem \
    "  -h|--help       print (this) message"
  show_listitem \
    "  -f|--force      run formatter regardless of MIME type"
  echo
  show_info "Specify a file to format a single file. Specify a directory to
recursively format _all_ files in it. Any files without MIME type
supported by this script will be ignored."
}


#
# Main
#

FORCE=false

OPTIONS=fhl:
LONGOPTIONS=force:help,language:
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "$0" -- "$@")
eval set -- "$PARSED"

while [ $# -ge 1 ]; do
  case "$1" in
    -f|--force)
      FORCE=true
      shift
      ;;
    -l|--language)
      LANGUAGE="${2}"
      shift 2
      ;;
    -h|--help)
      print_usage
      exit
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR"
      exit 3
      ;;
  esac
done

if [ $# -eq 1 ] && [ -f "${1}" ]; then
  format_wrapper "${1}"
else
  if check_command parallel; then
    find "${@:-.}" \
      \( -name ".git" -o -path "*/.*" \) -prune , -type f \
      -print0 | parallel -0 format_wrapper "{}"
  else
    find "${@:-.}" \
      \( -name ".git" -o -path "*/.*" \) -prune , -type f \
      -exec bash -c 'format_wrapper "${1}"' bash {} \;
  fi
fi
