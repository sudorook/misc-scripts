#! /bin/bash
set -euo pipefail
source globals

! check_command xrandr dconf && exit 3

# Map 2-character hexadecimal values (1 byte), in a format familiar to that
# found in the KeePassXC configuration file.
# - Two-character codes with preceding 0 are abbreviated to 1 character. For
#   example, '\x0d' is shortened to '\xd'.
# - Values with non-ambigious ASCII values are mapped directly to the
#   character. For example, '26' maps to '&'.
function convert_hex_to_bytestring {
  local hex="${1}"
  local bytestring
  case "${hex}" in
    20)
      bytestring=' '
      ;;
    21)
      bytestring='!'
      ;;
    22)
      bytestring='"'
      ;;
    23)
      bytestring='#'
      ;;
    24)
      bytestring='$'
      ;;
    25)
      bytestring='%'
      ;;
    26)
      bytestring='&'
      ;;
    27)
      bytestring="'"
      ;;
    28)
      bytestring='('
      ;;
    29)
      bytestring=')'
      ;;
    2A|2a)
      bytestring='*'
      ;;
    2B|2b)
      bytestring='+'
      ;;
    2C|2c)
      bytestring=','
      ;;
    2D|2d)
      bytestring='-'
      ;;
    2E|2e)
      bytestring='.'
      ;;
    2F|2f)
      bytestring='/'
      ;;
    3A|3a)
      bytestring=':'
      ;;
    3B|3b)
      bytestring=';'
      ;;
    3C|3c)
      bytestring='<'
      ;;
    3D|3d)
      bytestring='='
      ;;
    3E|3e)
      bytestring='>'
      ;;
    3F|3f)
      bytestring='?'
      ;;
    40)
      bytestring='@'
      ;;
    5B|5b)
      bytestring='['
      ;;
    5C|5c)
      bytestring='\'
      ;;
    5D|5d)
      bytestring=']'
      ;;
    5E|5e)
      bytestring='^'
      ;;
    5F|5f)
      bytestring='_'
      ;;
    60)
      bytestring='`'
      ;;
    7B|7b)
      bytestring='{'
      ;;
    7C|7c)
      bytestring='|'
      ;;
    7D|7d)
      bytestring='}'
      ;;
    7E|7e)
      bytestring='~'
      ;;
    00)
      bytestring='x0'  # Don't include the '\' yet -- it causes problems when passing strings around...
      ;;
    *)
      bytestring="x${hex#0}"  # Don't include the '\' yet -- it causes problems when passing strings around...
      ;;
  esac
  printf "${bytestring}"  # Use printf to avoid adding a newline to the bytestring.
}

# Converts an unsigned short int (2 bytes) to a byte array represented as
# hexadecimal values. The 2 bytes are split into two 1-byte halves and
# converted independently. Then, they are contatenated into the final byte
# string.
function convert_uint_to_bytestring {
  local int="${1}"
  local hex
  local str1
  local str2
  local bytestring
  printf -v hex "%.4x" "${int}"
  str1="$(convert_hex_to_bytestring "${hex:0:2}")"
  str2="$(convert_hex_to_bytestring "${hex:2:4}")"
  bytestring="${str1}${str2}"
  printf "${bytestring}"
}

function print_usage {
  show_header "Usage:"
  show_listitem "  -i|--input     display ID"
  show_listitem "  -r|--rotation  rotation (left, right, normal, or inverted)"
  show_listitem "  -h|--help      print (this) help message"
}

function get_primary_display_info_xrandr {
  local info
  local current_rotation
  if [[ -v 1 ]] && [[ -n "${1}" ]]; then
    info="$(xrandr -q | \
            sed -n "s/^${1} connected \(primary \)\?\([0-9]\+\)x\([0-9]\+\)[0-9+]\+ \([a-z]\+\)\?.*/\1|\2|\3|\4/p")"
  else
    info="$(xrandr -q | \
            sed -n "s/^\([A-Za-z0-9\-]\+\) connected primary \([0-9]\+\)x\([0-9]\+\)[0-9+]\+ \([a-z]\+\)\?.*/\1|\2|\3|\4/p")"
  fi
  if ! [ -n "${info}" ]; then
    show_error "ERROR: Failed to parse display info. Exiting."
    exit 3
  fi
  ID="$(cut -d"|" -f1 <<< "${info}")"
  if ! [ -n "${ID}" ]; then
    show_error "ERROR: Could not detect primary display. Exiting."
    exit 3
  fi
  current_rotation="$(cut -d"|" -f4 <<< "${info}")"
  if ! [ -n "${current_rotation}" ]; then
    show_warning "WARNING: Could not detect display rotation. Assuming 'normal'."
    current_rotation=normal
  fi
  case "${current_rotation}" in
    left|right)
      RESOLUTION_X="$(cut -d"|" -f3 <<< "${info}")"
      RESOLUTION_Y="$(cut -d"|" -f2 <<< "${info}")"
      ;;
    inverted|normal)
      RESOLUTION_X="$(cut -d"|" -f2 <<< "${info}")"
      RESOLUTION_Y="$(cut -d"|" -f3 <<< "${info}")"
      ;;
    *)
      show_error "ERROR: unknown rotation ${current_rotation@Q}."
      return
      ;;
  esac
  ROTATION=${ROTATION:-${current_rotation}}
}

function recenter_bleachbit {
  local width
  local height
  local offset_x
  local offset_y
  local config="${HOME}/.config/bleachbit/bleachbit.ini"
  if ! [ -f "${config}" ]; then
    show_warning "WARNING: Bleachbit config file missing. Skipping."
    return
  fi
  width="$(sed -n 's/window_width = \([0-9]\+\)/\1/p' ${config})"
  height="$(sed -n 's/window_height = \([0-9]\+\)/\1/p' ${config})"
  case "${ROTATION}" in
    left|right)
      offset_y=$(((RESOLUTION_X-height-PANEL_OFFSET-20)/2))  # 20 is hard-coded to match default display position
      offset_x=$(((RESOLUTION_Y-width)/2))
      ;;
    inverted|normal)
      offset_x=$(((RESOLUTION_X-width)/2))
      offset_y=$(((RESOLUTION_Y-height-PANEL_OFFSET-20)/2))  # 20 is hard-coded to match default display position
      ;;
    *)
      show_error "ERROR: unknown rotation ${ROTATION@Q}."
      return
      ;;
  esac
  sed -i.bak \
    -e "s/^\(window_width = \)[0-9]\+/\1${width}/g" \
    -e "s/^\(window_height = \)[0-9]\+/\1${height}/g" \
    -e "s/^\(window_x = \)[0-9]\+/\1${offset_x}/g" \
    -e "s/^\(window_y = \)[0-9]\+/\1${offset_y}/g" \
    ${config}
}

function recenter_keepassxc {
  local width
  local height
  local titlebar_height
  local x_left_to_left
  local x_left_to_right
  local y_top_to_titlebar_top
  local y_top_to_titlebar_bottom
  local y_top_to_bottom
  local screen_width
  local screen_height
  local geometry_string
  local geometry_string_new
  local config="${HOME}/.cache/keepassxc/keepassxc.ini"
  local geometry_array_uint=()
  local geometry_array_byte=()

  if ! [ -f "${config}" ]; then
    show_warning "WARNING: KeePassXC cache file ${config@Q} missing. Skipping."
    return
  fi

  geometry_string="$(sed -n "s/^MainWindowGeometry=@ByteArray(\(.*\))$/\1/p" "${config}")"
  read -a geometry_array_uint <<< "$(printf ${geometry_string} | od -A n -t u2 --endian=big | tr -d '\n')"

  # Compute the application dimensions from the geometry string. The '/2*2'
  # part of each expression is to ensure that the dimensions are even numbers
  # (there are divide-by-2 operations when computing the center), and the '+1'
  # is so that values are 'rounded' up to the nearest even number instead of
  # rounded down.
  width=$(((geometry_array_uint[9]-geometry_array_uint[5]+1)/2*2))
  height=$(((geometry_array_uint[11]-geometry_array_uint[15]+1)/2*2))
  titlebar_height=$(((geometry_array_uint[15]-geometry_array_uint[7]+1)/2*2))

  case "${ROTATION}" in
    left|right)
      x_left_to_left=$(((RESOLUTION_Y-width)/2))
      x_left_to_right=$(((x_left_to_left+width)))
      y_top_to_titlebar_top=$(((RESOLUTION_X-height-PANEL_OFFSET-20)/2))  # 20 is hard-coded to match default display position
      y_top_to_titlebar_bottom=$((y_top_to_titlebar_top+titlebar_height))
      y_top_to_bottom=$(((y_top_to_titlebar_bottom+height)))
      screen_width="${RESOLUTION_Y}"
      screen_height="${RESOLUTION_X}"
      ;;
    inverted|normal)
      x_left_to_left=$(((RESOLUTION_X-width)/2))
      x_left_to_right=$(((x_left_to_left+width)))
      y_top_to_titlebar_top=$(((RESOLUTION_Y-height-PANEL_OFFSET-20)/2))  # 20 is hard-coded to match default display position
      y_top_to_titlebar_bottom=$((y_top_to_titlebar_top+titlebar_height))
      y_top_to_bottom=$(((y_top_to_titlebar_bottom+height)))
      screen_width="${RESOLUTION_X}"
      screen_height="${RESOLUTION_Y}"
      ;;
    *)
      show_error "ERROR: unknown rotation ${ROTATION@Q}."
      return
      ;;
  esac

  geometry_array_uint[5]="${x_left_to_left}"
  geometry_array_uint[13]="${x_left_to_left}"
  geometry_array_uint[26]="${x_left_to_left}"
  geometry_array_uint[9]="${x_left_to_right}"
  geometry_array_uint[17]="${x_left_to_right}"
  geometry_array_uint[30]="${x_left_to_right}"
  geometry_array_uint[24]="${screen_width}"
  # geometry_array_uint[33]="${screen_height}"
  geometry_array_uint[7]="${y_top_to_titlebar_top}"
  geometry_array_uint[15]="${y_top_to_titlebar_bottom}"
  geometry_array_uint[28]="${y_top_to_titlebar_bottom}"
  geometry_array_uint[11]="${y_top_to_bottom}"
  geometry_array_uint[19]="${y_top_to_bottom}"
  geometry_array_uint[32]="${y_top_to_bottom}"

  local i
  for i in "${geometry_array_uint[@]}"; do
    geometry_array_byte+=($(convert_uint_to_bytestring "${i}"))
  done
  printf -v geometry_string_new '%s' "${geometry_array_byte[@]}"

  # Convert the 'xhh' values to '\xhh' and the 'x0's to '\0's.
  geometry_string_new="$(printf "${geometry_string_new}" | \
                         sed -e 's/x0/\\0/g' -e 's/x/\\x/g')"

  # ${geometry_string_new} is changed ('\' -> '\\') so '\'s next to '('s don't
  # get parsed as opening braces for capture groups.
  sed -i.bak \
    's/^MainWindowGeometry=@ByteArray(.*)$/MainWindowGeometry=@ByteArray('"${geometry_string_new//\\/\\\\}"')/g' \
    "${config}"
}

function recenter_transmission {
  local width
  local height
  local offset_x
  local offset_y
  local config="${HOME}/.config/transmission/settings.json"
  if ! [ -f "${config}" ]; then
    show_warning "WARNING: Transmission config file missing. Skipping."
    return
  fi
  width="$(sed -n 's/.*"main-window-width": \([0-9]\+\),/\1/p' ${config})"
  height="$(sed -n 's/.*"main-window-height": \([0-9]\+\),/\1/p' ${config})"
  case "${ROTATION}" in
    left|right)
      offset_y=$(((RESOLUTION_X-height-PANEL_OFFSET)/2))
      offset_x=$(((RESOLUTION_Y-width)/2))
      ;;
    inverted|normal)
      offset_x=$(((RESOLUTION_X-width)/2))
      offset_y=$(((RESOLUTION_Y-height-PANEL_OFFSET)/2))
      ;;
    *)
      show_error "ERROR: unknown rotation ${ROTATION@Q}."
      return
      ;;
  esac
  sed -i.bak \
    -e "s/\(.*\"main-window-width\": \)[0-9]\+,/\1${width},/g" \
    -e "s/\(.*\"main-window-height\": \)[0-9]\+,/\1${height},/g" \
    -e "s/\(.*\"main-window-x\": \)[0-9]\+,/\1${offset_x},/g" \
    -e "s/\(.*\"main-window-y\": \)[0-9]\+,/\1${offset_y},/g" \
    ${config}
}

function recenter_vlc {
  local width
  local height
  local titlebar_height
  local x_left_to_left
  local x_left_to_right
  local y_top_to_titlebar_top
  local y_top_to_titlebar_bottom
  local y_top_to_bottom
  local screen_width
  local screen_height
  local geometry_string
  local geometry_string_new
  local config="${HOME}/.config/vlc/vlc-qt-interface.conf"
  local geometry_array_uint=()
  local geometry_array_byte=()

  if ! [ -f "${config}" ]; then
    show_warning "WARNING: VLC QT config file ${config@Q} missing. Skipping."
    return
  fi

  geometry_string="$(sed -n "s/^geometry=@ByteArray(\(.*\))$/\1/p" "${config}")"
  read -a geometry_array_uint <<< "$(printf ${geometry_string} | od -A n -t u2 --endian=big | tr -d '\n')"

  # Compute the application dimensions from the geometry string. The '/2*2'
  # part of each expression is to ensure that the dimensions are even numbers
  # (there are divide-by-2 operations when computing the center), and the '+1'
  # is so that values are 'rounded' up to the nearest even number instead of
  # rounded down.
  width=$(((geometry_array_uint[9]-geometry_array_uint[5]+1)/2*2))
  height=$(((geometry_array_uint[11]-geometry_array_uint[15]+1)/2*2))
  titlebar_height=$(((geometry_array_uint[15]-geometry_array_uint[7]+1)/2*2))

  case "${ROTATION}" in
    left|right)
      x_left_to_left=$(((RESOLUTION_Y-width)/2))
      x_left_to_right=$(((x_left_to_left+width)))
      y_top_to_titlebar_top=$(((RESOLUTION_X-height-PANEL_OFFSET-20)/2))  # 20 is hard-coded to match default display position
      y_top_to_titlebar_bottom=$((y_top_to_titlebar_top+titlebar_height))
      y_top_to_bottom=$(((y_top_to_titlebar_bottom+height)))
      screen_width="${RESOLUTION_Y}"
      screen_height="${RESOLUTION_X}"
      ;;
    inverted|normal)
      x_left_to_left=$(((RESOLUTION_X-width)/2))
      x_left_to_right=$(((x_left_to_left+width)))
      y_top_to_titlebar_top=$(((RESOLUTION_Y-height-PANEL_OFFSET-20)/2))  # 20 is hard-coded to match default display position
      y_top_to_titlebar_bottom=$((y_top_to_titlebar_top+titlebar_height))
      y_top_to_bottom=$(((y_top_to_titlebar_bottom+height)))
      screen_width="${RESOLUTION_X}"
      screen_height="${RESOLUTION_Y}"
      ;;
    *)
      show_error "ERROR: unknown rotation ${ROTATION@Q}."
      return
      ;;
  esac

  geometry_array_uint[5]="${x_left_to_left}"
  geometry_array_uint[13]="${x_left_to_left}"
  geometry_array_uint[26]="${x_left_to_left}"
  geometry_array_uint[9]="${x_left_to_right}"
  geometry_array_uint[17]="${x_left_to_right}"
  geometry_array_uint[30]="${x_left_to_right}"
  geometry_array_uint[24]="${screen_width}"
  # geometry_array_uint[33]="${screen_height}"
  geometry_array_uint[7]="${y_top_to_titlebar_top}"
  geometry_array_uint[15]="${y_top_to_titlebar_bottom}"
  geometry_array_uint[28]="${y_top_to_titlebar_bottom}"
  geometry_array_uint[11]="${y_top_to_bottom}"
  geometry_array_uint[19]="${y_top_to_bottom}"
  geometry_array_uint[32]="${y_top_to_bottom}"

  local i
  for i in "${geometry_array_uint[@]}"; do
    geometry_array_byte+=($(convert_uint_to_bytestring "${i}"))
  done
  printf -v geometry_string_new '%s' "${geometry_array_byte[@]}"

  # Convert the 'xhh' values to '\xhh' and the 'x0's to '\0's.
  geometry_string_new="$(printf "${geometry_string_new}" | \
                         sed -e 's/x0/\\0/g' -e 's/x/\\x/g')"

  # ${geometry_string_new} is changed ('\' -> '\\') so '\'s next to '('s don't
  # get parsed as opening braces for capture groups.
  sed -i.bak \
    's/^geometry=@ByteArray(.*)$/geometry=@ByteArray('"${geometry_string_new//\\/\\\\}"')/g' \
    "${config}"
}

function rotate_cinnamon_monitor_xml {
  local config="${HOME}/.config/cinnamon-monitors.xml"
  if ! [ -f "${config}" ]; then
    show_warning "${config@} not found. Skipping."
  fi
  sed -i.bak \
    "s,<rotation>[a-z]\+</rotation>,<rotation>${ROTATION}</rotation>,g" \
    "${config}"
}

function parse_rotation {
  case ${ROTATION,,} in
    right)
      ROTATION=right
      ;;
    left)
      ROTATION=left
      ;;
    normal)
      ROTATION=normal
      ;;
    inverted)
      ROTATION=inverted
      ;;
    *)
      show_error "ERROR: invalid rotation ${ROTATION@Q}. Exiting."
      print_usage
      exit 3
      ;;
  esac
}

function rotate_display_xrandr {
  xrandr --output "${ID}" --rotate "${ROTATION}"
}

function change_gnome_desktop_bg {
  case ${ROTATION} in
    right|left)
      if [ -f "${VERTICAL_BG}" ]; then
        dconf write /org/gnome/desktop/background/picture-uri "'file://${VERTICAL_BG}'"
      else
        show_warning "Background ${VERTICAL_BG@Q} not found. Skipping."
      fi
      ;;
    normal|inverted)
      if [ -f "${HORIZONTAL_BG}" ]; then
        dconf write /org/gnome/desktop/background/picture-uri "'file://${HORIZONTAL_BG}'"
      else
        show_warning "Background ${HORIZONTAL_BG@Q} not found. Skipping."
      fi
      ;;
    *)
      show_error "ERROR: invalid rotation ${ROTATION@Q}. Exiting."
      print_usage
      exit 3
      ;;
  esac
}

function change_cinnamon_desktop_bg {
  case ${ROTATION} in
    right|left)
      if [ -f "${VERTICAL_BG}" ]; then
        dconf write /org/cinnamon/desktop/background/picture-uri "'file://${VERTICAL_BG}'"
      else
        show_warning "Background ${VERTICAL_BG@Q} not found. Skipping."
      fi
      ;;
    normal|inverted)
      if [ -f "${HORIZONTAL_BG}" ]; then
        dconf write /org/cinnamon/desktop/background/picture-uri "'file://${HORIZONTAL_BG}'"
      else
        show_warning "Background ${HORIZONTAL_BG@Q} not found. Skipping."
      fi
      ;;
    *)
      show_error "ERROR: invalid rotation ${ROTATION@Q}. Exiting."
      print_usage
      exit 3
      ;;
  esac
}

VERTICAL_BG="/usr/share/backgrounds/timed/24-hours-timed.xml"
HORIZONTAL_BG="/usr/share/backgrounds/timed/island-timed.xml"

PANEL_OFFSET=40  # height (in pixels) of the panel

OPTIONS=i:r:h
LONGOPTIONS=input:,rotation:,help
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "$0" -- "$@")
eval set -- "$PARSED"

while [ $# -ge 1 ]; do
  case "$1" in
    -i|--input)
      ID="$2"
      shift 2
      ;;
    -r|--rotation)
      ROTATION="$2"
      shift 2
      ;;
    -h|--help)
      print_usage
      shift
      exit
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR: invalid flag ${1@Q}."
      print_usage
      exit 3
      ;;
  esac
done

get_primary_display_info_xrandr "${ID:-}"
parse_rotation

case "${XDG_CURRENT_DESKTOP}" in
  X-Cinnamon)
    rotate_display_xrandr
    change_cinnamon_desktop_bg
    rotate_cinnamon_monitor_xml
    ;;
  GNOME)
    if [[ "${XDG_SESSION_TYPE}" = x11 ]]; then
      rotate_display_xrandr
      change_gnome_desktop_bg
    fi
    ;;
  *)
    show_error "ERROR: Environment ${XDG_CURRENT_DESKTOP@Q} unsupported. Exiting."
    exit 3
    ;;
esac

recenter_bleachbit
recenter_keepassxc
recenter_transmission
recenter_vlc
