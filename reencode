#! /bin/bash
set -Eeuo pipefail
source globals

! check_command ffmpeg ffprobe && exit 3


#
# Globals
#

function set_audio_bitrate {
  local in="${BACKUP}"
  local rate_per_stream=64
  local n_streams="${IN_ACHANNELS}"
  local abitrate # stores bitrate in kbps

  abitrate="$((rate_per_stream * n_streams))"

  if [[ "${IN_ABITRATE}" = 0 ]]; then
    echo "${abitrate}k"
  elif [[ "${abitrate}" -gt "${IN_ABITRATE}" ]]; then
    echo "${IN_ABITRATE}k"
  else
    echo "${abitrate}k"
  fi
}

function convert_codec {
  local in="${BACKUP}"
  local out
  local cmd

  cmd="ffmpeg -v info -i file:${in@Q} -map_chapters 0 -map_metadata 0"
  if [[ "${NOSUB}" = true ]]; then
    cmd="${cmd} -default_mode infer_no_subs -disposition:s -default"
  fi

  if [ -n "${VSTREAM_ID}" ]; then
    cmd="${cmd} -map 0:v:${VSTREAM_ID}"
  else
    cmd="${cmd} -map 0:v:?"
  fi

  if "${CROP}"; then
    cmd="${cmd} -vf '$(compute_crop_filter "${BACKUP}")'"
  fi

  # set video codec
  case "${OUT_VCODEC}" in
    h264|x264|libx264|h.264|x.264)
      cmd="${cmd} -c:v libx264 -x264-params crf=${CRF} -preset slow"
      ;;
    h265|x265|libx265|h.265|x.265)
      cmd="${cmd} -c:v libx265 -x265-params crf=${CRF} -preset slow"
      ;;
    copy)
      cmd="${cmd} -c:v copy"
      ;;
    *)
      show_error "ERROR: video codec ${OUT_VCODEC} is not supported. Exiting."
      exit 3
      ;;
  esac

  if [ -n "${ASTREAM_ID}" ]; then
    cmd="${cmd} -map 0:a:${ASTREAM_ID}"
  else
    cmd="${cmd} -map 0:a:?"
  fi

  # set audio codec
  case "${OUT_ACODEC}" in
    libfdk_aac|aac)
      # this only works for ffmpeg manually compiled with libfdk_aac
      if [[ -v OUT_ABITRATE ]]; then
        cmd="${cmd} -c:a libfdk_aac -b:a ${OUT_ABITRATE}"
      else
        cmd="${cmd} -c:a libfdk_aac -vbr 5"
      fi
      ;;
    libmp3lame|mp3lame|mp3)
      if [[ -v OUT_ABITRATE ]]; then
        cmd="${cmd} -c:a libmp3lame -b:a ${OUT_ABITRATE}"
      else
        cmd="${cmd} -c:a libmp3lame -b:a 320k"
      fi
      ;;
    libopus|opus)
      if [[ -v OUT_ABITRATE ]]; then
        cmd="${cmd} -c:a libopus -b:a ${OUT_ABITRATE}"
      else
        cmd="${cmd} -c:a libopus -b:a $(set_audio_bitrate)"
      fi
      ;;
    copy)
      cmd="${cmd} -c:a copy"
      ;;
    *)
      show_error "ERROR: audio codec ${OUT_ACODEC} not supported. Exiting."
      exit 3
      ;;
  esac

  # specify frame size if different from the input
  if ! [[ "${IN_DIMENSIONS}" = "${OUT_DIMENSIONS}" ]]; then
    # only add the size parameter if the output width/height are not larger
    # that the corresponding input values
    if [[ "$(echo "${IN_DIMENSIONS}" | cut -d"x" -f1)" -lt \
          "$(echo "${OUT_DIMENSIONS}" | cut -d"x" -f1)" ]] || \
       [[ "$(echo "${IN_DIMENSIONS}" | cut -d"x" -f2)" -lt \
          "$(echo "${OUT_DIMENSIONS}" | cut -d"x" -f2)" ]]; then
      show_warning \
        "WARNING: Dimensions ${OUT_DIMENSIONS} exceed input ${IN_DIMENSIONS}."
    else
      cmd="${cmd} -s ${OUT_DIMENSIONS}"
    fi
  fi

  # set subtitle format
  case "${OUT_CONTAINER}" in
    mp4)
      # convert subtitle format to mov_text for mp4 output
      if [[ "${IN_CONTAINER}" = "${OUT_CONTAINER}" ]]; then
        cmd="${cmd} -map 0:s:? -c:s copy"
      else
        cmd="${cmd} -map 0:s:? -c:s mov_text"
      fi
      ;;
    matroska|mkv)
      # convert 94213 to srt
      case "${IN_SCODEC}" in
        94213)
          cmd="${cmd} -map 0:s:? -c:s srt"
          ;;
        *)
          cmd="${cmd} -map 0:s:? -c:s copy"
          ;;
      esac
      ;;
    *)
      # copy subtitle codec by default
      cmd="${cmd} -map 0:s:? -c:s copy"
      ;;
  esac

  # manually specify the container format (ffmpeg may not infer from file name)
  case "${OUT_CONTAINER}" in
    avi)
      cmd="${cmd} -f avi"
      out="${NAME}.avi"
      ;;
    mpg)
      cmd="${cmd} -f mpg"
      out="${NAME}.mpg"
      ;;
    mkv|matroska)
      cmd="${cmd} -f matroska"
      out="${NAME}.mkv"
      ;;
    mp4)
      cmd="${cmd} -f mp4"
      out="${NAME}.mp4"
      ;;
    *)
      show_error "ERROR: Container ${CONTAINER} not supported. Exiting."
      exit 3
      ;;
  esac

  # add output
  cmd="${cmd} file:${out@Q}"

  show_header "Re-encoding ${in}:"
  show_info "${cmd}"
  eval "${cmd}"
}

function scan_input {
  local fstring
  # local astring
  local vstring
  # local sstring
  local format_name
  local in_width
  local in_height
  # local out_width
  # local out_height

  fstring="$(ffprobe -v error -show_format file:"${IN}")"
  vstring="$(ffprobe -v error \
               -select_streams v:0 -show_streams file:"${IN}")"
  astring="$(ffprobe -v error \
               -select_streams a:0 -show_streams file:"${IN}")"
  sstring="$(ffprobe -v error \
               -select_streams s:0 -show_streams file:"${IN}")"

  format_name="$(echo "${fstring}" | sed -n "s/^format_name=\(.*\)/\1/p")"
  if [[ "${format_name}" =~ matroska ]]; then
    IN_CONTAINER=matroska
  elif [[ "${format_name}" =~ mp4 ]]; then
    IN_CONTAINER=mp4
  else
    IN_CONTAINER=avi
  fi

  if ! [[ -v OUT_CONTAINER ]]; then
    OUT_CONTAINER="${IN_CONTAINER}"
  fi

  # IN_VCODEC="$(echo "${vstring}" | sed -n "s/^codec_name=\(.*\)$/\1/p")"
  # IN_ACODEC="$(echo "${astring}" | sed -n "s/^codec_name=\(.*\)$/\1/p")"
  IN_SCODEC="$(echo "${sstring}" | sed -n "s/^codec_name=\(.*\)$/\1/p")"

  IN_ACHANNELS="$(echo "${astring}" | sed -n "s/^channels=\(.*\)/\1/p")"
  IN_ABITRATE="$(echo "${astring}" | \
                 sed -n "s/^bit_rate=\(.*\)/scale=0;\1\/1000/p" | bc -l)" # kbps

  if ! [[ -v OUT_VCODEC ]]; then
    OUT_VCODEC=copy
  fi
  if ! [[ -v OUT_ACODEC ]]; then
    # OUT_ACODEC="${IN_ACODEC}"
    OUT_ACODEC=copy
  fi
  if ! [[ -v OUT_SCODEC ]]; then
    OUT_SCODEC=copy
  fi
  # if ! [[ -v OUT_SCODEC ]]; then
  #   # OUT_SCODEC="${IN_SCODEC}"
  #   if [[ "${IN_SCODEC}" = 94213 ]] && [[ "${OUT_CONTAINER}" = matroska ]]; then
  #     OUT_SCODEC=srt
  #   else
  #     OUT_SCODEC=copy
  #   fi
  # fi

  ASPECTRATIO="$(echo "${vstring}" | sed -n "s/^display_aspect_ratio=\(.*\)$/\1/p")"

  in_width="$(echo "${vstring}" | sed -n "s/^width=\(.*\)$/\1/p")"
  in_height="$(echo "${vstring}" | sed -n "s/^height=\(.*\)$/\1/p")"
  IN_DIMENSIONS="${in_width}x${in_height}"

  # DURATION="$(echo "${fstring}" | sed -n "s/^duration=\(.*\)$/\1/p")"

  if ! [[ -v FPS ]]; then
    FPS="$(echo "${vstring}" | sed -n "s/^r_frame_rate=\(.*\)$/\1/p" | bc -l)"
  fi
}

function check_compat {
  case "${OUT_CONTAINER}" in
    avi|AVI)
      case "${OUT_VCODEC}" in
        h264|x264|libx264|h.264|x.264|h265|x265|libx265|h.265|x.265)
          show_error "ERROR: ${OUT_CONTAINER} and ${OUT_VCODEC} incompatible."
          exit 3
          ;;
        *)
          ;;
      esac
      ;;
    *)
      ;;
  esac
}

function print_usage {
  show_header "Usage: reencode"
  echo "  -i|--input          input video"
  echo "  -a|--acodec         audio codec (copy, aac, opus, or mp3)"
  echo "  -v|--vcodec         video codec (h264 or h265)"
  echo "  -r|--crf            compression factor"
  echo "  -d|--dimensions     output dimensions (e.g. 1920x, 1280x720, etc.)"
  echo "  -c|--container      container format (matroska or mp4)"
}

function parse_container {
  case "${1}" in
    avi|AVI)
      OUT_CONTAINER=avi
      ;;
    mpg|MPG)
      OUT_CONTAINER=mpg
      ;;
    mkv|matroska|MKV|Matroska)
      OUT_CONTAINER=matroska
      ;;
    mp4|mpeg4|MP4|MPEG4|MPEG-4|m4v)
      OUT_CONTAINER=mp4
      ;;
    *)
      show_error "ERROR: Output ${IN_CONTAINER} containers not supported. Exiting."
      exit 3
  esac
}

function parse_vcodec {
  case "${1}" in
    h264|x264|libx264|h.264|x.264)
      OUT_VCODEC=libx264
      ;;
    h265|x265|libx265|h.265|x.265)
      OUT_VCODEC=libx265
      ;;
    *)
      show_error "ERROR: Video codec ${2} is not supported. Exiting."
      exit 3
      ;;
  esac
}

function parse_acodec {
  case "${1}" in
    libfdk_aac|aac)
      # this only works for ffmpeg manually compiled with libfdk_aac
      OUT_ACODEC=libfdk_aac
      ;;
    libmp3lame|mp3lame|mp3)
      OUT_ACODEC=libmp3lame
      ;;
    libopus|opus)
      OUT_ACODEC=libopus
      ;;
    copy)
      OUT_ACODEC=copy
      ;;
    *)
      show_error "ERROR: audio codec ${2} not supported. Exiting."
      exit 3
      ;;
  esac
}

function fill_dimensions {
  local out_width
  local out_height

  if ! [[ -v OUT_DIMENSIONS ]]; then
    OUT_DIMENSIONS="${IN_DIMENSIONS}"
  else
    out_width="$(echo "${OUT_DIMENSIONS}" | sed -n "s,^\([0-9]*\)[:x]\([0-9]*\)$,\1,p")"
    out_height="$(echo "${OUT_DIMENSIONS}" | sed -n "s,^\([0-9]*\)[:x]\([0-9]*\)$,\2,p")"
    if [ -z "${out_width}" ] && [ -n "${out_height}" ]; then
      out_width="$(printf %.0f "$(echo "${out_height} * ${ASPECTRATIO}" | sed 's,:,/,g' | bc -l)")"
    elif [ -n "${out_width}" ] && [ -z "${out_height}" ]; then
      out_height="$(printf %.0f "$(echo "${out_width} / (${ASPECTRATIO})" | sed 's,:,/,g' | bc -l)")"
    fi
    OUT_DIMENSIONS="${out_width}x${out_height}"
  fi
}

function compute_crop_filter {
  local cropfilter
  cropfilter="$(ffmpeg -i "${1}" -vf 'cropdetect=24:2:0' -f null - 2>&1 | \
                awk '/crop=/{ print $NF}' | tail -1)"
  echo "${cropfilter}"
}


#
# Parse command line options
#

NOSUB=false
CROP=false
ASTREAM_ID=
VSTREAM_ID=

OPTIONS=i:a:A:b:v:V:r:c:d:hnp
LONGOPTIONS=input:,acodec:,asteam_id:,bitrate:,vcodec:,vstream_id:,crf:,dimensions:,container:,help,nodefault,crop
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "$0" -- "$@")
eval set -- "$PARSED"
while [ $# -ge 1 ]; do
  case "$1" in
    -i|--input)
      IN="$2"
      scan_input
      NAME=${IN%.*}
      BACKUP="${IN}_$(date +%Y%m%d-%H%M%S).bak"
      shift 2
      ;;
    -a|--acodec)
      parse_acodec "${2}"
      shift 2
      ;;
    -A|--astream_id)
      ASTREAM_ID="${2}"
      shift 2
      ;;
    -b|--bitrate_audio)
      OUT_ABITRATE="${2}"
      shift 2
      ;;
    -v|--vcodec)
      parse_vcodec "${2}"
      shift 2
      ;;
    -V|--vstream_id)
      VSTREAM_ID="${2}"
      shift 2
      ;;
    -n|--nodefault)
      NOSUB=true
      shift 1
      ;;
    -r|--crf)
      CRF="${2}"
      shift 2
      ;;
    -d|--dimensions)
      OUT_DIMENSIONS="${2}"
      shift 2
      ;;
    -c|--container)
      parse_container "${2}"
      shift 2
      ;;
    -p|--crop)
      CROP=true
      shift 1
      ;;
    -h|--help)
      print_usage
      exit
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR: Unknown command line option."
      print_usage
      exit 3
      ;;
  esac
done


#
# Main
#

if ! [[ -v IN ]]; then
  show_error "ERROR: Input file not given."
  exit 3
fi

if ! [[ -f "${IN}" ]]; then
  show_error "ERROR: Input file not found."
  exit 3
fi

if ! [[ -v CRF ]]; then
  case "${OUT_VCODEC}" in
    libx264)
      CRF=18 # default 23
      ;;
    libx265)
      CRF=23 # default 28
      ;;
  esac
fi

fill_dimensions # must be called after scan_input has run
check_compat    # check whether output codecs and compatible

mv "${IN}" "${BACKUP}"

# set traps
if [[ "${IN_CONTAINER}" = "${OUT_CONTAINER}" ]]; then
  trap 'mv -f "${BACKUP}" "${IN}"; exit' INT TERM ERR
else
  if [[ "${OUT_CONTAINER}" = "matroska" ]]; then
    trap 'mv -f "${BACKUP}" "${IN}"; rm -f "${NAME}.mkv"; exit' INT TERM ERR
  else
    trap 'mv -f "${BACKUP}" "${IN}"; rm -f "${NAME}.${OUT_CONTAINER}"; exit' INT TERM ERR
  fi
fi

convert_codec
