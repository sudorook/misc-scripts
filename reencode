#! /bin/bash
set -Eeuo pipefail
source globals

! check_command ffmpeg ffprobe bc awk && exit 3

#
# Globals
#

A_BITRATE_PER_STREAM=64

NO_DEFAULT_SUBS=false
CROP=false


#
# Functions
#

function set_audio_bitrate {
  local in="${1}"
  local n_streams="${2}"
  local in_abitrate="${3}"
  local abitrate # stores bitrate in kbps

  abitrate="$((A_BITRATE_PER_STREAM * n_streams))"

  if [[ "${in_abitrate}" = 0 ]]; then
    echo "${abitrate}k"
  elif [[ "${abitrate}" -gt "${in_abitrate}" ]]; then
    echo "${in_abitrate}k"
  else
    echo "${abitrate}k"
  fi
}

function convert_codec {
  local in="${BACKUP}"
  local out
  local cmd
  local idx

  cmd="ffmpeg -v info -i file:${in@Q} -map_chapters 0 -map_metadata 0"
  if [[ "${NO_DEFAULT_SUBS}" = true ]]; then
    cmd="${cmd} -default_mode infer_no_subs -disposition:s -default"
  fi

  if [ -n "${VSTREAM_ID}" ]; then
    if ! [ "${VSTREAM_ID}" = "-1" ]; then
      cmd="${cmd} -map 0:v:${VSTREAM_ID}"
    fi
  else
    cmd="${cmd} -map 0:v:?"
  fi

  if "${CROP}"; then
    cmd="${cmd} -vf '$(compute_crop_filter "${BACKUP}")'"
  fi

  # set video codec
  case "${OUT_VCODEC}" in
    h264|x264|libx264|h.264|x.264)
      cmd="${cmd} -c:v libx264 -x264-params crf=${CRF} -preset slow"
      ;;
    h265|x265|libx265|h.265|x.265)
      cmd="${cmd} -c:v libx265 -x265-params crf=${CRF} -preset slow"
      ;;
    copy)
      cmd="${cmd} -c:v copy"
      ;;
    *)
      show_error "ERROR: video codec ${OUT_VCODEC@Q} is not supported. Exiting."
      exit 3
      ;;
  esac

  if [ -n "${ASTREAM_ID}" ]; then
    if ! [ "${ASTREAM_ID}" = "-1" ]; then
      cmd="${cmd} -map 0:a:${ASTREAM_ID}"
    fi
  else
    cmd="${cmd} -map 0:a:?"
  fi

  # set audio codec
  case "${OUT_ACODEC}" in
    libfdk_aac|aac)
      # this only works for ffmpeg manually compiled with libfdk_aac
      if [[ -v OUT_ABITRATE ]]; then
        cmd="${cmd} -c:a libfdk_aac -b:a ${OUT_ABITRATE}"
      else
        cmd="${cmd} -c:a libfdk_aac -vbr 5"
      fi
      ;;
    libmp3lame|mp3lame|mp3)
      if [[ -v OUT_ABITRATE ]]; then
        cmd="${cmd} -c:a libmp3lame -b:a ${OUT_ABITRATE}"
      else
        cmd="${cmd} -c:a libmp3lame -b:a 320k"
      fi
      ;;
    libopus|opus)
      if [[ -v OUT_ABITRATE ]]; then
        cmd="${cmd} -c:a libopus -b:a ${OUT_ABITRATE}"
      else
        # set computed bitrates individually for each channel because input
        # channels can have different bitrates and channel layouts
        cmd="${cmd} -c:a libopus"
        if [ -n "${ASTREAM_ID}" ]; then
          if ! [ "${ASTREAM_ID}" = "-1" ]; then
            cmd="${cmd} -b:a:0 $(set_audio_bitrate \
                                   "${BACKUP}" \
                                   "${IN_ASTREAM_CHANNEL_COUNT[${ASTREAM_ID}]}" \
                                   "${IN_ASTREAM_BITRATE[$ASTREAM_ID]}")"
            if [[ "${IN_ASTREAM_CHANNEL_LAYOUT[${ASTREAM_ID}]}" = "5.1(side)" ]]; then
              show_warning "WARNING: converting layout from 5.1(side) to 5.1."
              cmd="${cmd} -channel_layout:a:${ASTREAM_ID} 5.1"
            fi
          fi
        else
          for idx in $(seq 0 $(( ${#IN_ASTREAM_CHANNEL_COUNT[@]} - 1 ))); do
            cmd="${cmd} -b:a:${idx} $(set_audio_bitrate \
                                        "${BACKUP}" \
                                        "${IN_ASTREAM_CHANNEL_COUNT[${idx}]}" \
                                        "${IN_ASTREAM_BITRATE[$idx]}")"
            if [[ "${IN_ASTREAM_CHANNEL_LAYOUT[${idx}]}" = "5.1(side)" ]]; then
              show_warning "WARNING: converting layout from 5.1(side) to 5.1."
              cmd="${cmd} -channel_layout:a:${idx} 5.1"
            fi
          done
        fi
      fi
      ;;
    copy)
      cmd="${cmd} -c:a copy"
      ;;
    *)
      show_error "ERROR: audio codec ${OUT_ACODEC@Q} not supported. Exiting."
      exit 3
      ;;
  esac

  # specify frame size if different from the input
  if ! [[ "${IN_DIMENSIONS}" = "${OUT_DIMENSIONS}" ]]; then
    # only add the size parameter if the output width/height are not larger
    # that the corresponding input values
    if [[ "$(echo "${IN_DIMENSIONS}" | cut -d"x" -f1)" -lt \
          "$(echo "${OUT_DIMENSIONS}" | cut -d"x" -f1)" ]] || \
       [[ "$(echo "${IN_DIMENSIONS}" | cut -d"x" -f2)" -lt \
          "$(echo "${OUT_DIMENSIONS}" | cut -d"x" -f2)" ]]; then
      show_warning \
        "WARNING: Dimensions ${OUT_DIMENSIONS@Q} exceed input ${IN_DIMENSIONS@Q}."
    else
      cmd="${cmd} -s ${OUT_DIMENSIONS}"
    fi
  fi

  # set subtitle format
  case "${OUT_CONTAINER}" in
    mp4)
      # convert subtitle format to mov_text for mp4 output
      if [[ "${IN_CONTAINER}" = "${OUT_CONTAINER}" ]]; then
        cmd="${cmd} -map 0:s:? -c:s copy"
      else
        cmd="${cmd} -map 0:s:? -c:s mov_text"
      fi
      ;;
    matroska|mkv)
      # convert 94213 to srt
      case "${IN_SCODEC}" in
        94213)
          cmd="${cmd} -map 0:s:? -c:s srt"
          ;;
        *)
          cmd="${cmd} -map 0:s:? -c:s copy"
          ;;
      esac
      ;;
    *)
      # copy subtitle codec by default
      cmd="${cmd} -map 0:s:? -c:s copy"
      ;;
  esac

  # copy any attachments
  cmd="${cmd} -map 0:t:? -c:t copy"

  # manually specify the container format (ffmpeg may not infer from file name)
  case "${OUT_CONTAINER}" in
    avi)
      cmd="${cmd} -f avi"
      out="${NAME}.avi"
      ;;
    mpg)
      cmd="${cmd} -f mpg"
      out="${NAME}.mpg"
      ;;
    mkv|matroska)
      cmd="${cmd} -f matroska"
      out="${NAME}.mkv"
      ;;
    mp4)
      cmd="${cmd} -movflags +faststart -f mp4"
      out="${NAME}.mp4"
      ;;
    mp3)
      cmd="${cmd} -f mp3"
      out="${NAME}.mp3"
      ;;
    flac)
      cmd="${cmd} -f flac"
      out="${NAME}.flac"
      ;;
    *)
      show_error "ERROR: Container ${OUT_CONTAINER@Q} not supported. Exiting."
      exit 3
      ;;
  esac

  if [[ -n "${EXTRA}" ]]; then
    cmd="${cmd} ${EXTRA}"
  fi

  # add output
  cmd="${cmd} file:${out@Q}"

  show_header "Re-encoding ${in@Q}:"
  show_info "${cmd}"
  eval "${cmd}"
}

function scan_input {
  local fstring
  local astring
  local vstring
  local sstring
  local format_name
  local in_width
  local in_height
  # local out_width
  # local out_height

  fstring="$(ffprobe -v error -show_format file:"${IN}")"
  vstring="$(ffprobe -v error \
               -select_streams v:0 -show_streams file:"${IN}")"
  sstring="$(ffprobe -v error \
               -select_streams s:0 -show_streams file:"${IN}")"

  format_name="$(echo "${fstring}" | sed -n "s/^format_name=\(.*\)/\1/p")"
  case "${format_name}" in
    matroska|mkv|matroska,webm|webm)
      IN_CONTAINER=matroska
      ;;
    mp4|mov,mp4,m4a,3gp,3g2,mj2|m4a|mov)
      IN_CONTAINER=mp4
      ;;
    mp3)
      IN_CONTAINER=mp3
      ;;
    avi)
      IN_CONTAINER=avi
      ;;
    flac)
      IN_CONTAINER=flac
      ;;
    *)
      show_error "ERROR: ${format_name@Q} unsupported. Exiting."
      exit 3
      ;;
  esac

  if ! [[ -v OUT_CONTAINER ]]; then
    OUT_CONTAINER="${IN_CONTAINER}"
  fi

  # IN_VCODEC="$(echo "${vstring}" | sed -n "s/^codec_name=\(.*\)$/\1/p")"
  # IN_ACODEC="$(echo "${astring}" | sed -n "s/^codec_name=\(.*\)$/\1/p")"
  IN_SCODEC="$(echo "${sstring}" | sed -n "s/^codec_name=\(.*\)$/\1/p")"

  IN_ASTREAM_CHANNEL_COUNT=()
  IN_ASTREAM_CHANNEL_LAYOUT=()
  IN_ASTREAM_BITRATE=()
  while read -r astring; do
    IN_ASTREAM_CHANNEL_COUNT+=("$(echo "${astring}" | cut -d"|" -f3)")
    IN_ASTREAM_CHANNEL_LAYOUT+=("$(echo "${astring}" | cut -d"|" -f4)")
    IN_ASTREAM_BITRATE+=("$(echo "${astring}" | cut -d"|" -f5)")
  done <<< "$(ffprobe -v error \
                -select_streams a \
                -show_entries stream=codec_type,channels,channel_layout,bit_rate \
                -of compact=nokey=1 file:"${IN}")"

  if ! [[ -v OUT_VCODEC ]]; then
    OUT_VCODEC=copy
  fi
  if ! [[ -v OUT_ACODEC ]]; then
    # OUT_ACODEC="${IN_ACODEC}"
    OUT_ACODEC=copy
  fi
  if ! [[ -v OUT_SCODEC ]]; then
    OUT_SCODEC=copy
  fi
  # if ! [[ -v OUT_SCODEC ]]; then
  #   # OUT_SCODEC="${IN_SCODEC}"
  #   if [[ "${IN_SCODEC}" = 94213 ]] && [[ "${OUT_CONTAINER}" = matroska ]]; then
  #     OUT_SCODEC=srt
  #   else
  #     OUT_SCODEC=copy
  #   fi
  # fi

  ASPECTRATIO="$(echo "${vstring}" | sed -n "s/^display_aspect_ratio=\(.*\)$/\1/p")"

  in_width="$(echo "${vstring}" | sed -n "s/^width=\(.*\)$/\1/p")"
  in_height="$(echo "${vstring}" | sed -n "s/^height=\(.*\)$/\1/p")"
  IN_DIMENSIONS="${in_width}x${in_height}"

  # DURATION="$(echo "${fstring}" | sed -n "s/^duration=\(.*\)$/\1/p")"

  if ! [[ -v FPS ]]; then
    FPS="$(echo "${vstring}" | sed -n "s/^r_frame_rate=\(.*\)$/\1/p" | bc -l)"
  fi
}

function check_compat {
  case "${OUT_CONTAINER}" in
    avi|AVI)
      case "${OUT_VCODEC}" in
        h264|x264|libx264|h.264|x.264|h265|x265|libx265|h.265|x.265)
          show_error "ERROR: ${OUT_CONTAINER} and ${OUT_VCODEC} incompatible."
          exit 3
          ;;
        *)
          ;;
      esac
      ;;
    *)
      ;;
  esac
}

function print_usage {
  show_header "Usage: reencode"
  echo "  -i|--input          input video"
  echo "  -a|--acodec         audio codec (copy, aac, opus, or mp3)"
  echo "  -A|--astream_id     select index of one audio stream to encode"
  echo "  -b|--bitrate_audio  set global audio output bitrate"
  echo "  -v|--vcodec         video codec (h264 or h265)"
  echo "  -V|--vstream_id     select index of one video stream to encode"
  echo "  -r|--crf            set constant rate factor for video encoding"
  echo "  -p|--crop           use ffcropdetect to crop video"
  echo "  -n|--nodefault      set no subtitles to be shown by default"
  echo "  -d|--dimensions     output dimensions (e.g. 1920x, 1280x720, etc.)"
  echo "  -c|--container      container format (matroska or mp4)"
  echo "  -e|--extra          extra ffmpeg cli string"
}

function parse_container {
  case "${1}" in
    avi|AVI)
      OUT_CONTAINER=avi
      ;;
    mpg|MPG)
      OUT_CONTAINER=mpg
      ;;
    mkv|matroska|MKV|Matroska)
      OUT_CONTAINER=matroska
      ;;
    mp4|mpeg4|MP4|MPEG4|MPEG-4|m4v)
      OUT_CONTAINER=mp4
      ;;
    mp3|MP3)
      OUT_CONTAINER=mp3
      ;;
    flac|FLAC)
      OUT_CONTAINER=flac
      ;;
    *)
      show_error "ERROR: Output ${1@Q} containers not supported. Exiting."
      exit 3
  esac
}

function parse_vcodec {
  case "${1}" in
    h264|x264|libx264|h.264|x.264)
      OUT_VCODEC=libx264
      ;;
    h265|x265|libx265|h.265|x.265)
      OUT_VCODEC=libx265
      ;;
    copy)
      OUT_VCODEC=copy
      ;;
    *)
      show_error "ERROR: Video codec ${1@Q} is not supported. Exiting."
      exit 3
      ;;
  esac
}

function parse_acodec {
  case "${1}" in
    libfdk_aac|aac)
      # this only works for ffmpeg manually compiled with libfdk_aac
      OUT_ACODEC=libfdk_aac
      ;;
    libmp3lame|mp3lame|mp3)
      OUT_ACODEC=libmp3lame
      ;;
    libopus|opus)
      OUT_ACODEC=libopus
      ;;
    copy)
      OUT_ACODEC=copy
      ;;
    *)
      show_error "ERROR: Audio codec ${1@Q} not supported. Exiting."
      exit 3
      ;;
  esac
}

function fill_dimensions {
  local out_width
  local out_height

  if ! [[ -v OUT_DIMENSIONS ]]; then
    OUT_DIMENSIONS="${IN_DIMENSIONS}"
  else
    out_width="$(echo "${OUT_DIMENSIONS}" | sed -n "s,^\([0-9]*\)[:x]\([0-9]*\)$,\1,p")"
    out_height="$(echo "${OUT_DIMENSIONS}" | sed -n "s,^\([0-9]*\)[:x]\([0-9]*\)$,\2,p")"
    if [ -z "${out_width}" ] && [ -n "${out_height}" ]; then
      out_width="$(printf %.0f "$(echo "${out_height} * ${ASPECTRATIO}" | sed 's,:,/,g' | bc -l)")"
    elif [ -n "${out_width}" ] && [ -z "${out_height}" ]; then
      out_height="$(printf %.0f "$(echo "${out_width} / (${ASPECTRATIO})" | sed 's,:,/,g' | bc -l)")"
    fi
    OUT_DIMENSIONS="${out_width}x${out_height}"
  fi
}

function compute_crop_filter {
  local cropfilter
  cropfilter="$(ffmpeg -i file:"${1}" -vf 'cropdetect=24:2:0' -f null - 2>&1 | \
                awk '/crop=/{print $NF}' | tail -1)"
  echo "${cropfilter}"
}


#
# Parse command line options
#

ASTREAM_ID=
VSTREAM_ID=
EXTRA=

OPTIONS=i:e:a:A:b:v:V:r:c:d:hnp
LONGOPTIONS=input:,extra:,acodec:,asteam_id:,bitrate:,vcodec:,vstream_id:,crf:,dimensions:,container:,help,nodefault,crop
PARSED=$(getopt -o ${OPTIONS} --long ${LONGOPTIONS} -n "$0" -- "$@")
eval set -- "$PARSED"
while [ $# -ge 1 ]; do
  case "$1" in
    -i|--input)
      IN="$2"
      scan_input
      NAME=${IN%.*}
      BACKUP="${IN}_$(date +%Y%m%d-%H%M%S).bak"
      shift 2
      ;;
    -e|--extra)
      EXTRA="${2}"
      shift 2
      ;;
    -a|--acodec)
      parse_acodec "${2}"
      shift 2
      ;;
    -A|--astream_id)
      ASTREAM_ID="${2}"
      shift 2
      ;;
    -b|--bitrate_audio)
      OUT_ABITRATE="${2}"
      shift 2
      ;;
    -v|--vcodec)
      parse_vcodec "${2}"
      shift 2
      ;;
    -V|--vstream_id)
      VSTREAM_ID="${2}"
      shift 2
      ;;
    -n|--nodefault)
      NO_DEFAULT_SUBS=true
      shift 1
      ;;
    -r|--crf)
      CRF="${2}"
      shift 2
      ;;
    -d|--dimensions)
      OUT_DIMENSIONS="${2}"
      shift 2
      ;;
    -c|--container)
      parse_container "${2}"
      shift 2
      ;;
    -p|--crop)
      CROP=true
      shift 1
      ;;
    -h|--help)
      print_usage
      exit
      ;;
    --)
      shift
      break
      ;;
    *)
      show_error "ERROR: Unknown command line option."
      print_usage
      exit 3
      ;;
  esac
done


#
# Main
#

if ! [[ -v IN ]]; then
  show_error "ERROR: Input file not given."
  exit 3
fi

if ! [[ -f "${IN}" ]]; then
  show_error "ERROR: Input file not found."
  exit 3
fi

if ! [[ -v CRF ]]; then
  case "${OUT_VCODEC}" in
    libx264)
      CRF=18 # ffmpeg default is 23 if unspecified
      ;;
    libx265)
      CRF=23 # ffmpeg default is 28 if unspecified
      ;;
  esac
fi

fill_dimensions # must be called after scan_input has run
check_compat    # check whether output codecs and compatible

mv "${IN}" "${BACKUP}"

# set traps
if [[ "${IN_CONTAINER}" = "${OUT_CONTAINER}" ]]; then
  trap 'mv -f "${BACKUP}" "${IN}"; exit' INT TERM ERR
else
  if [[ "${OUT_CONTAINER}" = "matroska" ]]; then
    trap 'mv -f "${BACKUP}" "${IN}"; rm -f "${NAME}.mkv"; exit' INT TERM ERR
  else
    trap 'mv -f "${BACKUP}" "${IN}"; rm -f "${NAME}.${OUT_CONTAINER}"; exit' INT TERM ERR
  fi
fi

convert_codec
sync
